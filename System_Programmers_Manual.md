# Purpose

This is a Markdown version of the Cogar C4/Singer 1501/ICL 1501 System Programmers Manual (1972)

Please enter any defect from the original as a github issue.

# TODO

Check all examples formatting

# Section I. GENERAL

# SPECIFICATION SUMMARY

**Size**  
- 10 inches high (25 cm)  
- 18.5 inches wide (47 cm)  
- 24 inches deep (60 cm)  

**Weight**  
- 60 pounds (27 kg)  

**Power**  
- 115 VAC ±10%, 220 VAC ±10%  
- 48 to 62 Hz  
- 2.5 amps average  

**Environment**  
- 10% to 80% relative humidity without condensation  
- 60°F to 95°F Operating Temperature  
- 0°F to 150°F Storage Temperature  

**Ventilation**  
- 30 cubic feet per minute air flow  
- 4 inches air flow clearance on all sides  
- 1000 BTU per hour heat dissipation  

**Processor**  
- 45 instruction types plus I/O  
- 3 to 6 μs instruction cycle time  
- 1 Accumulator  
- 7 Index Registers per 2K of memory  
- 16 Member Instruction Address Stack  
- Hardware Bootstrap Loader  

**Memory**  
- 16K bytes capacity  
- Random Access Read/Write  
- Non-Destructive Read-Out  
- Monolithic Semiconductor  

**Keyboard**  
- Software configurable  
- Hall effect keys  
- N-Key rollover capability  
- Audible cue  

**Visual Display**  
- 5 inch CRT  
- 4 or 8 line display, with interleave capability  
- 32 characters per line  
- 5 x 8 matrix under program control  

**Tape System**  
- 10 ips write tape speed  
- 1600 bpi density, phase modulation  
- 2 mechanically independent transports  
- Read after Write, CRC, phase checks  
- Automatic threading  
- Write interlock switch  
- Rewind: 40 ips rewind and forward or rewind search  

**Tape Cartridges**  
- 100 ft. computer grade tape  
- 900 records of 136 characters each  
- Write/Erase Protection  


## 1. SYSTEM FEATURES

The Cogar System 4 is a compact, operator-oriented, general purpose data 
processing system. It combines, in a single unit, an input keyboard, 
magnetic tape transports, CRT visual display, I/O interface, solid state 
memory and a versatile processor. The System architecture closely in­
tegrates the functioning of all sub-systems and features transparency of 
graphics and coding. All major system functions are under program control. 
The processor structure is designed to optimize byte handling and inter­
pretation, and provides automatic threading of recursive subroutines. 

The nature of the processor design and its relationship to the other 
system components make the Cogar 4 heavily dependent on software. This 
means that the system is uniquely flexible in the jobs it can perform and 
is especially adaptable for various operator and interface applications. 
It also means that software is an essential ingredient that must be as 
fully and carefully integrated into the System as the other components. 

The Cogar 4 is a binary machine using 8-bit bytes in its memory organ­
ization and most hardware data paths. Its operations are highly memory 
oriented and are designed to take advantage of the performance of its 
semiconductor storage. 


## 2. LANGUAGE FEATURES

The language base for the Cogar System 4 is flexible, easy to learn and 
use, yet permits the programmer to take full advantage of the System 4's 
power. The Cogar Language Base is comprised of a comprehensive set of 
"Pre-packaged" functions to facilitate modular program construction. 
The Cogar Assembler provides linkage between these functions and the 
specialized routines necessary to a given application. 

Programs are written and assembled in symbolic notation, with the 
final stage of the assembly effecting a merge of the specialized 
routines and the pre-packaged background functions. This method of 
assembly allows easy and rapid modification or correction of programs 
or the re-configuration of a program to accommodate different peripheral 
devices or the selection of a new or modified graphic set, or key­
board configuration. 

The DPL-1 instructions for the Cogar 4 are machine level instructions 
that are directly executed while the DPL-2 commands are executed inter­
pretively by a resident software monitor. DPL-1 instructions are two 
bytes long and must occur on even byte boundaries. DPL-2 commands are 
four bytes long and should also occur on even boundaries. When DPL-1 and 
DPL-2 are intermixed, a new language is formed called DPL-3. The batch 
assembler for DPL-3 is known as DPL-3B. A subset of the DPL-2 monitor 
that handles I/O function is known as the I/O Supervisor or IOS. This 
manual describes DPL-1 and IOS as assembled on DPL-3B. 

In order to be able to tailor the system for optimum use with particular 
applications, many device functions have been designed for program control. 
The codes generated by the keyboard, for example, correspond not to the 
key character, but to the key location. A translate table is located in 
the processor memory and is used to convert a key code into a character 
code. The user program can easily modify the translate table and can thus 
produce any desired code for any key. 

The visual display uses a 5 x 8 dot matrix to form each display character 
and has cursor control with each character. The dot matrix is stored in 
the processor memory so that any possible 5 x 8 combination may be 
generated by the user program to be displayed for any character code. 
The standard dot pattern uses a 5 x 7 dot matrix to form the desired 
character. This provides for a space between the character and the cursor. 

The Cogar 4 provides an unusually efficient subroutine control mechanism 
that is easy to use, yet offers powerful capabilities. 

## 3. IOS FEATURES

Cogar has designed an Input/Output Supervisor to provide easy access for 
the user to a set of standard I/O routines. The flexibility of the system 
peripheral device operations is still available for special applications, 
but most I/O operations can be accommodated by the I/O Supervisor. IOS 
is a memory resident software monitor that is accessed using the ENT:IOS 
pseudo command. It performs a complete single operation and automatically 
returns control to the user program. 

## 4. ASSEMBLER FEATURES

Computer programs must always eventually be expressed in machine language. 
The machine only understands binary numbers and programs so expressed are 
called Object programs. There are some circumstances when it is desirable 
for the system user to be able to write Object instructions directly. 
Most of the time, however, it is much more efficient to use an instruction 
language that is easily interpreted by the user. The mnemonic expressions 
used to represent the Object language form a Symbolic language. An 
Assembler is a program that translates a Symbolic program into an Object 
program. 

Since the programmer spends much of his time communicating with the 
Assembler, it is useful to supply commands that control the operations 
of the Assembler itself. These commands are called Pseudo instructions 
and normally do not result in any Object coding. Another class of Pseudo 
instructions used in the Cogar 4 Assembler to control executive monitor 
operations does generate Object coding. 

The Cogar Batch Assembler, known as DPL-3B, provides many features de­
signed to streamline the programming process. Comments may be inserted 
in the Symbolic program to help identify the operations taking place. 
Instructions, data, constants and locations may all be referred to 
symbolically. Diagnostics are generated to help identify errors in the 
program. Editing, display and printing of both Object and Symbolic 
programs are available as part of the DPL-3B package. 

The Cogar Assembler also handles the appropriate translations, controls, 
and linkages for the IOS and DPL-3 monitors. 

## 5. DISPLAY

### Keyboard Transparency: 

The Cogar System 4 is designed to provide code hardware transparency. 
Any keyboard character may be automatically translated to any desired 
code and any dot matrix pattern may be displayed for a given character 
code. These functions are directly under software control and are thus 
available to the programmer. 

### Selective Blanking: 

The commonly used internal key and character codes in standard Cogar 
software are shown in Table 1. Notice that the high order octal digit 
is always zero. This digit corresponds to the bits six and seven of 
the character byte. If a 1 is inserted in bit 7 (changing the code for 
A, for example, from 015(0x0D) to 215(0x8D)) of a character in the CRT 
buffer area, that character will be displayed on the screen as a blank. 

### Cursor Underscore: 

If a 1 is inserted in bit 6 (changing the code for A, for example, from 
015(0x0D) to 115(0x4D)) of a character in the CRT buffer area, that 
character may be displayed with an underline. The underline feature must 
be enabled by adding octal 1 to the second octal digit of the display 
base enable function codes. Thus, to permit underlines in display base 2 
the normal display enable of IOC, C#3; 023(0x13) becomes IOC, C#4; 033(0x1B). 
The underline feature is a convenient means of providing a cursor. 

### Selective Interlace: 

Memory areas displayed are program selectable from any one of 16 memory 
Pages (256 bytes per Page), with provision for half Page (128 bytes) dis­
play only or for selective interlace of half-Pages. 


## 6. KEYBOARD

When a character key is depressed on the keyboard after a Transfer Byte 
IOC, it causes a key code to be loaded into the accumulator. The NUM 
(numeric), CTRL (control) and ALPHA (alphabetic) are three special keys 
that act on bits 6 and 7 of the key code for any key pressed while one 
of them is held down. NUM turns on bit 6, CTRL turns on bit 7, and 
ALPHA turns on both 6 and 7. If none of the special keys are activated, 
bits 6 and 7 remain off. The following procedure may be used to translate 
the key code residing in the accumulator into a character code.

a. The 6th and 7th bits are taken care of as follows:

6th bit on: do not change  
7th bit on: turn 7th bit off (reset after translation, if desired).  
6th and 7th bits on: turn 6th and 7th bits off (reset after translation, if desired).

b. Store the result in an index register.

c. Add to the index register the displacement within the page of the 
beginning of the translate table. The standard translate table in 
page 05, for example, starts at location decimal 064, therefore, add 
decimal 064 to the value of the index register containing the key code 
before translation.

d. Load the Accumulator using indexed addressing and the page where the 
translate table resides. The Accumulator now contains the character 
code for the key that was depressed. The translate table may be 
designed by the user to supply any desired 8 bit character code 
including ASCII, EBCDIC, etc.

## 7. CARTRIDGE TAPES

The resident software I/O Supervisor provides for the actual reading, 
writing and tape positioning of the Mini-Tape. The user will often want 
to test the status of the tape drives for his own purposes. For example, 
to check the presence of a cartridge on a particular tape drive, first 
execute a Status instruction (IOC, C#N; 016), then test with a mask of 
020 (TMJ, +NN; OCT:020). If the condition is satisfied, the cartridge 
is not present. Any of the status byte conditions may be tested by first 
loading the status of the device in question into the accumulator, and 
then testing it against the literal mask specified.

### Write Pin Enable

A Write Pin Sensor in the SYSTEM 4 requires that if a tape is to be 
written on, the Write plug must be in the proper position. Otherwise, 
tape will not move and no write operation can be performed on that deck 
until a cartridge is inserted with the write pin in place.

### Physical End of Tape Sensing

The SYSTEM 4 tape cartridges contain a reflective spot to notify the 
program that during a write operation, the Physical End of Tape is 
approaching. The user may write beyond this point if so desired. The 
Mini-tape Write Software function detects this condition and provides 
the tape status for the user to test. Once the EOT is detected, this 
condition remains set until a Rewind operation is initiated.


## 8. OPERATOR CONTROLS

A Switch Well located beneath the CRT screen contains eight sense 
switches, a Program Load/Program Interrupt switch, and a System Reset 
switch.

### Sense Switches

These eight toggle switches may be manually set by the user to any 
combination of eight bits. The setting of these switches may then be 
tested by the user program at selected times, to control specialized 
applications.

### Program Load/Program Interrupt Switch

This toggle switch initiates a tape load cycle when pushed toward the 
CRT (Momentary position), or initiates a Program Interrupt when set in 
the ON position (away from the CRT screen).

With the switch set to ON, the user program may test the condition to 
provide automatic linkage to the Interrupt Routine. Return to the point 
of interrupt will occur after the interrupt routine has been completed, 
and an Exit instruction to the Stack Level established by the interrupt 
has been executed.

### System Reset Switch

When this push button switch is pressed, a System Reset pulse is 
generated which resets the Stack Pointer to Stack Level 1 and forces 
the instruction address to P02-000 where processing is then initiated.





## Table I — Key and Character Codes for Cogar 4 Keypunch Keyboard

| Key         | Key Code (Octal) | Char Code (Octal) |
|-------------|------------------|-------------------|
| Space       | 070 (0x38)       | 000 (0x00)        |
| -           | 010 (0x08)       | 001 (0x01)        |
| +           | 116 (0x4E)       | 002 (0x02)        |
| )           | 111 (0x49)       | 003 (0x03)        |
| 1           | 124 (0x54)       | 004 (0x04)        |
| 2           | 125 (0x55)       | 005 (0x05)        |
| 3           | 126 (0x56)       | 006 (0x06)        |
| 4           | 145 (0x65)       | 007 (0x07)        |
| 5           | 146 (0x66)       | 010 (0x08)        |
| 6           | 147 (0x67)       | 011 (0x09)        |
| 7           | 164 (0x74)       | 012 (0x0A)        |
| 8           | 165 (0x75)       | 013 (0x0B)        |
| 9           | 166 (0x76)       | 014 (0x0C)        |
| A           | 037 (0x1F)       | 015 (0x0D)        |
| B           | 062 (0x32)       | 016 (0x0E)        |
| C           | 060 (0x30)       | 017 (0x0F)        |
| D           | 041 (0x21)       | 020 (0x10)        |
| E           | 020 (0x10)       | 021 (0x11)        |
| F           | 042 (0x22)       | 022 (0x12)        |
| G           | 043 (0x23)       | 023 (0x13)        |
| H           | 044 (0x24)       | 024 (0x14)        |
| I           | 025 (0x15)       | 025 (0x15)        |
| J           | 045 (0x25)       | 026 (0x16)        |
| K           | 046 (0x26)       | 027 (0x17)        |
| L           | 047 (0x27)       | 030 (0x18)        |
| M           | 064 (0x34)       | 031 (0x19)        |
| N           | 063 (0x33)       | 032 (0x1A)        |
| O           | 026 (0x16)       | 033 (0x1B)        |
| P           | 027 (0x17)       | 034 (0x1C)        |
| Q           | 016 (0x0E)       | 035 (0x1D)        |
| R           | 021 (0x11)       | 036 (0x1E)        |
| S           | 040 (0x20)       | 037 (0x1F)        |
| T           | 022 (0x12)       | 040 (0x20)        |
| U           | 024 (0x14)       | 041 (0x21)        |
| V           | 061 (0x31)       | 042 (0x22)        |
| W           | 017 (0x0F)       | 043 (0x23)        |
| X           | 056 (0x2E)       | 044 (0x24)        |
| Y           | 023 (0x13)       | 045 (0x25)        |
| Z           | 053 (0x2B)       | 046 (0x26)        |
| ,           | 065 (0x35)       | 047 (0x27)        |
| ,           | 103 (0x43)       | 047 (0x27)        |
| #           | 102 (0x42)       | 050 (0x28)        |
| @           | 002 (0x02)       | 051 (0x29)        |
| %           | 003 (0x03)       | 053 (0x2B)        |
| $           | 104 (0x44)       | 054 (0x2C)        |
| *           | 004 (0x04)       | 055 (0x2D)        |
|             | 105 (0x45)       | 056 (0x2E)        |
|             | 066 (0x36)       | 056 (0x2E)        |
| <           | 005 (0x05)       | 057 (0x2F)        |
| >           | 140 (0x60)       | 060 (0x30)        |
| /           | 011 (0x09)       | 061 (0x31)        |
| (           | 163 (0x73)       | 062 (0x32)        |
| )           | 120 (0x50)       | 063 (0x33)        |
| ?           | 156 (0x6E)       | 064 (0x34)        |
| ¢           | 121 (0x51)       | 065 (0x35)        |
| =           | 161 (0x71)       | 066 (0x36)        |
| ‖           | 160 (0x70)       | 067 (0x37)        |
| !           | 162 (0x72)       | 070 (0x38)        |
| I           | 144 (0x64)       | 071 (0x39)        |
| :           | 141 (0x61)       | 072 (0x3A)        |
| .           | 142 (0x62)       | 073 (0x3B)        |
| -           | 117 (0x4F)       | 074 (0x3C)        |
| ,           | 143 (0x63)       | 075 (0x3D)        |
| &           | 127 (0x57)       | 076 (0x3E)        |
| \|          | 123 (0x53)       | 077 (0x3F)        |

### Control Keys

| Key         | Key Code (Octal) | Char Code (Octal) |
|-------------|------------------|-------------------|
| START       | 001 (0x01)       | 201 (0x81)        |
| MINUS       | 006 (0x06)       | 206 (0x86)        |
| DUP         | 007 (0x07)       | 207 (0x87)        |
| PROG SELECT | 012 (0x0A)       | 212 (0x8A)        |
| REL         | 013 (0x0B)       | 213 (0x8B)        |
| BKSP RECORD | 014 (0x0C)       | 214 (0x8C)        |
| END FILE    | 015 (0x0D)       | 215 (0x8D)        |
| BKSP FIELD  | 030 (0x18)       | 230 (0x98)        |
| LEFT ZERO   | 031 (0x19)       | 231 (0x99)        |
| ERROR       | 032 (0x1A)       | 232 (0x9A)        |
| SKIP        | 050 (0x28)       | 250 (0xA8)        |
| HOM         | 051 (0x29)       | 251 (0xA9)        |
| CORR        | 067 (0x37)       | 267 (0xB7)        |
| EOJ         | 071 (0x39)       | 271 (0xB9)        |




# Section II. INSTRUCTION USAGE

## 1. SUBROUTINE CONTROL

The Instruction Address Stack (IAS) is located in memory and consists of 
sixteen Instruction Address Words (IAW) of two bytes each. Access to the 
Stack is under control of a four-bit register called the Stack Pointer. 
The current instruction address is contained in the IAW indicated by the 
Stack Pointer.

During sequential instruction operations, the Instruction Address is re­
trieved from the IAW, used to locate the current instruction, incremented 
by two, and inserted back into the IAW. For branch operations, a new 
Instruction Address is inserted into the current IAW and execution con­
tinues with the new address.

To enter a subroutine, the Stack Pointer is incremented so that it now 
points to a new IAW location and the subroutine address is inserted in the 
Stack as the new IAW. Normal sequential operation then proceeds. Note 
that the content of the previous IAW has not been disturbed and may be 
returned to by simply decrementing the Stack Pointer with an Exit instruc­
tion. Thus it is not necessary to provide space in the sub-routine for 
return address storage. If more than 16 levels of stack and branching 
has occurred an automatic wrap-around to stack level 1 will be initiated.



### Figure 2 : Snapshot of Instruction Address Stack after EXU Instruction (See Example)**

### Stack Layout – IAW and DPL

| IAW   | Octal Loc.         | DPL Page           |
|-------|--------------------|--------------------|
| IAW1  | Address: 040₈      | Address: 041₈      |
|       | CONTENT: 053₈      | CONTENT: 010₈      |
| IAW2  | Address: 042₈      | Address: 043₈      |
|       | CONTENT: 221₈      | CONTENT: 013₈      |
| IAW3  | Address: 044₈      | Address: 045₈      |
|       | CONTENT:           | CONTENT:           |
| IAW4  | Address: 046₈      | Address: 047₈      |
|       | CONTENT:           | CONTENT:           |
| IAW5  | Address: 050₈      | Address: 051₈      |
|       | CONTENT:           | CONTENT:           |
| ...   |                    |                    |
| IAW15 | Address: 074₈      | Address: 075₈      |
|       | CONTENT:           | CONTENT:           |
| IAW16 | Address: 076₈      | Address: 077₈      |
|       | CONTENT:           | CONTENT:           |

### STACK
(Stack grows downward, with Stack Pointer indicating current position)


### EXAMPLE:

| PPP-LLL: MP1-MP2-MP3-MP4 | E SEQ. NO. | LAB: | VERB | OPERANDS       | COMMENTS   |
|--------------------------|------------|------|------|----------------|------------|
| P10-050: 200-024.         | P1-010.    | EAB: | LDA, | R#0; OCT:024. |            |
| P10-052: 123-174.         | P1-020.    |      | SBU: | DLY.          |            |
| P10-054: 237-054.         | P1-030.    |      | STA, | R#7; P11.     |            |
| P13-174: 233-011.         | P1-040.    | DLY: | STA, | R#0; L#1.     |            |
| P13-176: 233-234.         | P1-050.    |      | LDX, | R#3; DEC:156. |            |
| P13-200: 014-027.         | P1-060.    |      | TLJ, | +12; (K).     |            |
| P13-220: 140-000.         | P1-070.    |      | EXU: | 000.          |            |


Figure 2 is a diagram of the IAS and shows the actual octal locations of 
the stack bytes in page 77. Assume that the Stack Pointer is indicating 
IAW1 as the location of the current Instruction Address. Sequential or 
Branch operations of the mainline program change the contents of IAW1 but 
do not affect the Stack Pointer. When the mainline program encounters 
a Stack and Branch instruction, however, the Stack Pointer is incremented 
to indicate IAW2 and the Branch address is inserted into IAW2. If the 
Stack and Branch instruction was located at Page 10, location 52, IAW1 
will now contain the coding to indicate Page 10, location 52, and IAW2 
will become the current location counter. The subroutine indicated by 
IAW2 may reference other subroutines in which case IAW3, IAW4, etc. may 
be used. When the IAW2 subroutine is finished, an Exit instruction is 
executed which simply decrements the Stack Pointer and returns program 
control to IAW1 at the instruction following the original Stack and 
Branch. If the exit instruction was located at Page 13, location 220, 
IAW2 will be left with the coding for Page 13, location 220. A subsequent 
mainline Stack and Branch would insert a new Branch address into IAW2.

Note that the low order bit of the location may be on. This bit must be 
removed, by using the "ANA" instruction if the user desires to use this 
address after a load processor status operation (See "LPS" instruction).


### Figure 3 : Instruction Address Word Layout.

```
+-------------------------------++-------------------------------+
|      Byte 1 (Octal Loc.)      ||       Byte 2 (DPL Page)       |
+-------------------------------++-------+-----------+-----------+
|           LOCATION            || U | V |  Section  |    Page   |
|                               ||Bit|Bit|   Number  |   Number  |
+---------------+---+---+-------++-------+-----------+-----------+
|   |   |   |   |   |   |   |   ||   |   |   |   |   |   |   |   |
+---+---+---+---+---+---+---+---++---+---+---+---+---+---+---+---+

* INSTRUCTION LOCATION : (Octal 000 to 376)

* U Bit: MEMORY CONTROL
- 0 = Direct Address within Section 0, Page 0.  
- 1 = Direct Address within **current** section, Page 0.

* V Bit: RELOCATABLE BRANCH CONTROL
- 0 = Normal processing.  
- 1 = Relocatable Branch functions. (See SMC Instruction)

* SECTION NUMBER: Section 0 through Section 7.

* PAGE NUMBER: Page 0 through Page 7 (within a section).
```





## 2. REGISTERS

The Cogar 4 contains one general purpose accumulator that is eight bits 
(one byte) long. Almost all of the nonbranch DPL-1 instructions refer 
to the accumulator. It is the major center for processor activity 
and the primary pipeline for data flow to and from the memory and the 
peripheral devices. 

The Cogar 4 contains seven one-byte index registers for each memory 
section available. They are often used as address displacements in 
indexed addressing, but may also be used as general purpose registers. 
A few of the DPL-1 instructions act directly on the index registers, 
but there is much more flexibility than those instructions imply because 
the registers are located in memory. They may thus be addressed by all 
memory reference instructions. The accumulator can retrieve, manipulate 
and restore the contents of any index register. 

The hardware condition register contains the results of Test and Compare 
instructions. It may be set to High, Equal or Low and retains its status 
until a new Test or Compare is executed. The operation of DPL-1 con­ditional
Branch instructions depends on the status of the hardware con­dition register.

## 3. ADDRESSING

The Cogar 4 contains 4K, 8K or 16K bytes of memory, with an IAW 16 bits 
long. Indirect addressing may operate anywhere within this range. The 
total memory capacity is divided into eight Sections of 2048 bytes each. 
requiring 11 bits to fully address. Branch operations (if not preceded by 
a "SMS" instruction) may refer only to locations within a Section. Each 
Section is further divided into eight pages of 256 bytes each, requiring 
eight bits to fully address. Direct addressing (page 0 of the current 
control section) or relocatable subroutines (branch operations with 
page 0 assigned) may refer to one page only. 

The object formats shown with the instruction descriptions include the 
following Binary Notations: 

Z = 1 bit frame 

y = 2 bit frame 

X = 3 bit frame 

JJ = 4 bit frame 

### Instruction Addressing: 

All instruction addressing is relocatable page oriented. The address 
specification, in octal notation (object), is Pnn-LLL where nn = SL, 
S is the Section number, L is the Level number and LLL is the byte 
location within the page. 

All instructions are retrieved from memory using the current Instruction 
Address Word, and all instruction addressing involves modification of the 
IAW. 

For sequential execution of instructions, one of the sixteen IAW's within 
the Stack is incremented by two during each instruction cycle. Instruc­
tions may be executed sequentially within a Section or across Section 
boundaries. It is important to note that when instructions cross a 
Section boundary, the branch functions, if executed, will transfer con­
trol to the Section that was previously set. Other functions are not 
affected. A "Set Memory Section" instruction is used to change the 
section context of the IAW for branch instructions. 

A jump to a new instruction location uses relative instruction addressing 
by adding or subtracting up to 15 instruction locations to or from the 
current IAW. A Jump may be across a Section Boundary. 

### ADDRESS NOTATIONS

| Format | Type | Description |
|--------|------|-------------|
| AAA    | DDD  | Absolute Address, in decimal notation |
|        | SSS  | Symbolic Address |
|        | RRR  | Symbolic Branch Reference |
|        | NNN  | Address Adjustment for Symbolic Addresses, in decimal notation |
| PPP    | Pnn  | Absolute Page Number, in decimal notation |
|        | SSS  | Symbolic Page Number |


### Data Addressing

Data is addressed by an instruction in three different modes:  
**Immediate**, **Direct**, and **Indexed**.

#### Immediate Addressing Mode
When using the Immediate Addressing Mode, the operand itself, instead of the operand address, is assembled within the instruction as a self-defining literal.  
The literal represents data rather than an address of data.  
Literals provide a means of entering constants into a program by specifying the constant in the operand of the instruction in which it is used.  
Immediate Addressing is differentiated from Direct Addressing by the operand form.

#### Direct Addressing Mode
Direct Addressing Mode uses the instruction operand as the address of a byte location for all page numbers within level 0.  
This mode is utilized by specifying in the operand any form of Direct Address notation.  
All DPL-1 functions may take this form of operand except Class 0 and Class 1 Instructions.

#### Indexed Addressing Mode
The Indexed Addressing Mode provides a method of addressing data anywhere within memory.  
An Indexed Address is composed of a displacement address contained in a specified index register plus a base address contained in the operand.  
The register specifies the location within a page and the operand specifies the page within memory.  
The index register in use may be unchanged, incremented by one, or decremented by one following the indexed operation.

There are three forms of register notation used to specify this option.  
`X` may be any integer from 1 through 7:

- **R#X** = Retain Register Value  
- **I#X** = Increment Register after Instruction Execution  
- **D#X** = Decrement Register after Instruction Execution  

When an overflow occurs (**I#X**), the overflow bit is lost and the register contains octal `000`.  
When an underflow occurs (**D#X**), the result is the two's complement of the underflow count.

## 4. SYMBOLS

Program elements, such as instructions or constants, may be referenced 
in an instruction by specifying the absolute address of the element. The 
form for this type of reference is Pnn, LLL. Pnn specifies the page in 
2 digit decimal notation from 00 to 63 and LLL specifies the location 
within the page in 3 digit decimal notation from 000 to 255. 

It is often more convenient to refer to program elements symbolically. 
In the DPL-3B Assembler, a symbol is a combination of characters used to 
represent a program element. Symbols are defined through their use in 
the label field of an instruction or through the EQU pseudo instruction. 
A Symbol may be used only once in a label field within one program. When 
a symbol is used as an instruction operand, it must be defined somewhere 
in the program. A symbol must be comprised of three non-blank alpha­
numeric characters with the first character non-numeric. If the first 
character is "P", the following characters must be alphabetic. The 
total number of symbols plus ORG statements plus page boundaries crossed 
by sequential program operation is limited to a maximum of 128. 

Address adjustment may be used for convenience and to cut down on the 
number of symbols defined. A signed numeric adjustment in decimal bytes 
from 0 to 255 may be appended to a symbolic reference or may be used re­
lative to the current location. An "*" (asterisk) is used to indicate 
the location of the first byte of the current instruction. 

The I/O Control Instruction micro-codes provide for control, status 
and data exchange between the processor and its interface devices. Tape 
channels may be selected, tape motions initiated, and read or write 
commanded; the keyboard may be read or beeped; the CRT may be enabled or 
disabled; the I/O interface transmission may be started or stopped, and 
data or control bytes written. With the CRT enabled, the data content 
of any memory page which has a section or level number of less than 5 
may be displayed in four-line consecutive mode, eight-line consecutive 
mode, or eight-line interleaved mode. Several status checks are avail­
able for the processor to interrogate. Most normal I/O operations will 
use the I/O Supervisor, but special purpose routines may be constructed 
from the IOC instructions and there are several operations, like key­
board beep, that are not available from the IOS. 

## 5. DPL-1 INSTRUCTION CLASSES

The DPL-1 instruction set includes all hardware instructions and is div­
ided into four general classes covering all types of operations required 
of a general purpose processor. 

Class 0: Jump and Conditional Exit Instructions 

Class 1: Branch, Linkage-Control, and I/O Instructions 

Class 2: Data-Transfer and Arithmetic Instructions 

Class 3: Boolean and Compare Instructions 

### Class 0: Jump Instructions: 

Jump instructions transfer control within a context to a location 
relative. to the current instruction location. All Jump Instructions are 
conditional and depend on the result of a test of the contents of the 
accumulator. The test comparison, the test mask, the Jump direction and 
the jump increment are all specified in the instruction. The Jump in­
crement is expressed in the instruction itself as the octal number of 
two-byte instructions to be jumped. However, the Batch Assembler uses 
a decimal byte count for the Jump increment. Test results are stored 
in the hardware condition register. For the TMJ and TMX instructions, 
an unconditional Jump or Exit, and the setting of the condition register 
to equal, can be effected by using a test mask of zero. 

### Class 1: Branch, Linkage-Control, and I/O Instructions: 

Branch instructions transfer control outside a context to any section 
address. Branch instructions replace the current IAW with a new instruc­
tion address. Stack and Branch instructions introduce a new instruction 
address in a new IAW and preserve the contents of the previous IAW for 
return linkage. Direct Branch instructions may be conditioned by pre­
vious test or compare operations. The conditional instructions allow 
powerful data-dependent decisions to be made. The Exit and the Exit and 
Branch instructions are used to return from subroutines. They decrement 
the stack pointer and thus change program control to the next previous 
IAW. 

### Class 2: Data Transfer and Arithmetic Instructions: 

This class of instructions includes the Load and Store operations that 
allow data to be moved between memory and the accumulator or index 
registers. These instructions use immediate, direct, or indexed address­
ing modes. When loading or storing using indexed addressing, the 
specified index register may be automatically incremented or decremented. 

The arithmetic instructions in this class include Binary add and subtract 
operations on the accumulator or the index registers. Immediate, direct, 
or indexed addressing may be used. Automatic increment or decrement of 
index registers may be specified when using indexed addressing. All 
operations are available for use with the accumulator. Some operations 
may also be performed on index registers. 

### Class 3: Boolean and Compare Instructions: 

The Boolean instructions in this class include immediate, direct or 
indexed addressing of And, Inclusive Or, and Exclusive Or operations. 
The immediate instructions allow for up to seven right circular shifts 
of the accumulator prior to operation with the literal. 

The Compare instructions compare the contents of the accumulator with 
a location specified by immediate, direct or indexed addressing. Any 
index register may be compared with a literal. The comparison results 
are stored in the condition register and may be tested by any following 
conditional Branch instruction. In indexed addressing of both Boolean 
and Compare instructions, the specified index register may be auto­
matically incremented or decremented. 

## 6. DPL PUNCTUATION

Rather than an implicit syntax, the DPL grammar provides an explicit 
syntax by use of punctuation. Four punctuation characters are used: 
the semi-colon, the comma, the colon and the period. 

The semi-colon is used as an imperative terminator or a major field 
delimiter. It usually separates the instruction field from the operand 
field. 

The comma is used as a minor field terminator. It separates multiple 
field instructions or operands. 

The colon is used as a declarative terminator. It follows instruction 
labels, pseudo instructions and constant designators. 

The period is used as a closing terminator and defines the end of the 
symbolic instruction. 

## 7. LITERAL NOTATIONS

Literal notations may be classified as explicit terms or as implicit 
terms. Explicit literals are self-defining because they include the 
specific value to be used. The four explicit literal forms are 
Character, Octal, Hexadecimal, and Decimal. They provide a means of 
specifying values or bit configurations without equating the values to 
symbols. The value of an explicit literal is assembled into an in­
struction. The value of a symbolic constant resides in memory and its 
address is assembled into an instruction. 

Literals that are assigned a value by the DPL-3B Assembler use five 
forms of address constants in which AAA is a symbolic address. These 
are: ADC:AAA, ADL:AAA, ADP:AAA, IDP:AAA, and DDP:AAA. These address 
constants are used primarily to define the actual address of a 
symbolic reference. When the literal form ADP, IDP, or DDP is used 
in conjunction with an R#0 or an R#X, instruction, the DPL page value 
of AAA is assembled as the operand; either with no indexing tag, or 
with incrementing or decrementing tag, respectively. If the form ADL 
is used, the address location value within the page is assembled as 
the operand. 

When the literal form ADC is used in conjunction with an R#0 
instruction, the DPL page value, in increment form, is assembled as 
the operand. If used in conjunction with an R#X instruction, the 
symbolic address location within the page is assembled as the operand. 

## 8. STANDARD C4 PROGRAM RECORD (MINI-TAPE)

8. STANDARD C4 PROGRAM RECORD (Mini-Tape) 

The Standard Mini-Tape Record is comprised of an 8-byte label, generated 
by the Mini-Write Software Function, followed by 128 bytes of data. The 
8-byte label when read into (or written from) memory resides in Page 00, 
locations 030 thru 037. The first byte of the Record Header contains 
a sequence number. The sequence number is automatically checked by 
the Mini-Read Software Function to provide a method of automatically 
bypassing any "CIG" (Character in Gap). This sequence number may also 
be used to adjust search counters when utilizing the high-speed 
capability to locate multiple records by continuation. Byte-2 contains 
the control function. A value other than those specified below may be 
inserted by the user for specialized functions. Bytes 3 and 4 are not 
used by the Standard Mini-Read/Write, and can, therefore, contain any 
value as established by the user. 

Bytes 5 through 8 of a program record contain the Segment ID and the 
Page Designator. Through usage of these bytes, an overlay record can 
easily be located and loaded into memory. Bytes 5 through 8 are not 
used in a data file. 

### Figure 4 : Standard Mini-Tape Record Layout. 

#### Layout
- **8 bytes** – Header  
- **128 bytes** – Data  

---

#### Header Breakdown

| Byte | Field       | Description |
|------|-------------|-------------|
| 1 | **S**       | Binary Sequence Number starting with `001` and continually incremented with wraparound |
| 2 | **C**       | Control Byte: `375₈` = End of Program Load, `377₈` = End of File Indicator |
| 3 - 4 | **Not Used** | Reserved |
| 5 - 7| **PID**       | Program ID – inserted by the O-String Generation Phase from the "SEG" ID or the "OVL" ID. (Not used in data files.) |
| 8 | **Page alloc** | Page allocation (Not used in data files.) |

DPL Page of Record
Page Allocation
---

#### Page Allocation Field

| Bit | | Description |
|------|-------------|-------------|
| 6-2 | DLP Page of record |
|  1  | **0** = Lower half of Page (`000₈` thru `177₈`) |
|     | **1** = Upper half of Page (`200₈` thru `377₈`) |
|  0  | **0** = Non-Relocatable |
|     | **1** = Relocatable |



## 9. SUBROUTINE RELOCATABILITY

A method has been provided to allow the user to write subroutines that 
may be executed within any Page without re-assembling the subroutine 
for that Page. By executing a SET Memory Control Command that sets the 
Relocatable Branch Control (RBC) Bit, any Branch, Stack and Branch or 
Exit and Branch Instruction given with Page 0 specified in the Branch 
Address will cause the Branch to occur within the current Section and 
Page of the program. If any Page other than 0 is specified in the 
Branch Address, the RBC-Bit is Inactive and a normal Branch function 
will occur.

## 10. TAPE I/O CHARACTER QUEUE

The SYSTEM 4 tape logic contains an 8-bit character buffer that will 
hold a character for 512 usec., allowing this much time for other 
processing before the user must return to the I/O operation. 






## 11. IMMEDIATE ADDRESSING CODING




For DPL-1 instructions that use Immediate Addressing, the following 
forms may be used in symbolic coding to specify the literal value: 

(K)  
Where K is a valid keyboard character  

OCT:NNN  
Where NNN is a one-byte constant in OCTAL notation from 000(0x00) to 377(0xFF).  

HEX:HH  
Where HH is a one-byte constant in HEXADECIMAL notation from 00 to FF.  

DEC:NNN  
Where NNN is a one-byte constant in DECIMAL notation from 000 to 255.  

ADP:AAA  
Where AAA is an address constant for a PAGE in symbolic notation (without Auto Indexing).  

IDP:AAA  
Where AAA is an address constant for a PAGE in symbolic notation (with Increment Auto Indexing).  

DDP:AAA  
Where AAA is an address constant for a PAGE in symbolic notation (with Decrement Auto Indexing).  

ADL:AAA  
Where AAA is an address constant for a LOCATION in symbolic notation.  

ADC:AAA  
An address constant for labels, in symbolic notation (will generate page or location dependent on the Instruction form).  

AAA±NNN  
Where AAA is a symbolic address with a signed decimal byte adjustment from 0 to 255.  

# Section III. INSTRUCTION DESCRIPTIONS

## 1. GENERAL

SECTION III. INSTRUCTION DESCRIPTIONS 

The instructions described in this section of the manual are 
presented in the same order as they appear on the Cogar System 4 
Instruction Reference Card, and fall in the following four categories: 

1. DPL-1 Instructions. These instructions perform all the data 
manipulation and control tasks allowed by the hardware. 

2. IOS Commands. These instructions provide access to the standard 
software I/O routines, using the I/O Supervisor. 

3. Pseudo Instructions. These instructions provide programmer 
control over the DPL-3B Assembler, and the resident monitors. 

4. Constants. Byte constants or string constants may be generated 
using these notations. 

---
## 2. CLASS 0: JUMP

### DPL-1              CLASS 0: JUMP              TEST LITERAL AND JUMP

|      OBJECT      |          SOURCE            |
| ---------------- | -------------------------- |
| 00JJ0-LLL       | TLJ, +NN; Literal.         |
| 00JJ1-LLL       | TLJ, -NN; Literal.         |

WHERE: JJ is the jump count in 4 Bit
Binary notation, indicating
the number of 2-Byte instructions
to be jumped.

AND: LLL is an 8 Bit Literal.

WHERE: NN is the jump count in
decimal notation, indicating
the number of bytes to be jumped.

NOTE: This jump count must
always be an even decimal
number (Max:30).

#### DESCRIPTION:

The Accumulator is compared to the byte of immediate data (literal), and
the result is indicated in the condition register. Comparison is binary, and
all codes are valid. If the resulting condition register is equal, a jump forward (+)
or a jump backward (-) up to 15 two-byte instruction locations is performed.
If however the resulting condition register is not equal (high or low), the
next sequential instruction is executed. The character in the Accumulator
is not changed. Once set, the condition register remains unchanged until
modified by the next jump or compare instruction that reflects a different
condition code.

#### NOTE:

The condition register contains the true arithmetic condition (high or
low) after an unsuccessful jump (unequal condition).

| Condition | Test |
| --------- | ----- |
| HIGH      | ACCUM > LITERAL    |
| LOW       | ACCUM < LITERAL   |
| EQUAL     | ACCUM = LITERAL    |

#### TIMING:
3 Microseconds if the jump is not performed.
4 Microseconds if the jump is performed.

#### EXAMPLE:

```
PPP-LLL:   MP1-MP2-MP3-MP4.   E SEQ. NO.   LAB:   VERB   OPERANDS     COMMENTS
P15-000:   012-015.            01-120.      TLJ, +10; (A).             JUMP IF
P15-002:   013-016.            01-130.      TLJ, -10; OCT:016.         ACCUM IS
P15-004:   006-015.            01-140.      TLJ, +06; DEC:013.         EQUAL
P15-006:   004-017.            01-150.      TLJ, +04; HEX:0F.
```

---


### DPL-1 -- CLASS 0: JUMP -- TEST MASK AND JUMP -- TMJ+, TMJ-  

|      OBJECT      |          SOURCE            |  
|------------------|----------------------------|  
| 001JJ0-MMM       | TMJ, +NN; LT-MASK.         |  
| 001JJ1-MMM       | TMJ, -NN; LT-MASK.         |  

WHERE: JJ is the jump count in 4 Bit  
Binary notation, indicating  
the number of 2-Byte Instructions  
to be jumped.  

AND: MMM is an 8 Bit Literal Mask.  

WHERE: NN is the jump count in  
decimal notation, indicating  
the number of bytes to be jumped.  

NOTE: This jump count must  
always be an even decimal  
number (Max:30).  

#### DESCRIPTION:  

The state of the Accumulator bits selected by a mask is used to set the condition code.  

The byte of Immediate Data (Literal-Mask) is used as an eight-bit mask. The bits of the mask are made to correspond one for one with the bits of the character in the Accumulator. A mask bit of one indicates that the corresponding Accumulator bit is to be tested. When the mask bit is zero, the corresponding Accumulator bit is ignored. When any of the Accumulator bits thus selected are zero, the Condition Register is made unequal. When the selected bits are all-one, the Condition Register is made equal. If the resulting Condition Register is equal, jump forward (+) or jump back (-) up to 15 two-byte instruction locations. On the resulting Condition Register not equal (high or low), execute the next sequential instruction. The character in the Accumulator is not changed. Once set, the Condition Register remains unchanged until modified by an instruction that reflects a different condition code.  

#### NOTE:
The content of the Condition Register is unpredictable after an unsuccessful jump (unequal condition).  

#### TIMING:  
3 Microseconds if the jump is not performed.  
4 Microseconds if the jump is performed.  

#### EXAMPLE:  

```
PPP-LLL:   MP1-MP2-MP3-MP4.   E SEQ. NO.   LAB:   VERB   OPERANDS     COMMENTS  
P15-010:   050-016.            02-010.      TMJ, +08; OCT:016.        JUMP IF  
P15-012:   051-050.            02-020.      TMJ, -08; DEC:040.        MASK IS  
P15-014:   076-377.            02-030.      TMJ, +30; HEX:FF.         EQUAL  
```
---

### DPL-1 -- CLASS 0: JUMP -- TEST LITERAL AND EXIT -- TLX  

|      OBJECT      |          SOURCE            |  
|------------------|----------------------------|  
| 000-LLL          | TLX, 000; Literal.         |  

WHERE: LLL is an 8 bit Literal.  

#### DESCRIPTION:  

The Accumulator is compared to the byte of immediate data (literal), and the  
result is indicated in the Condition Register. Comparison is binary, and all  
codes are valid. If the resulting Condition Register is equal, then a special  
form of exit, (conditional exit) is performed, which completes the return  
linkage established by the last executed stack and branch instruction. The  
stack pointer is decremented to the preceding stack level, which contains the  
address of the last stack and branch instruction executed. This address is  
then incremented by 2 bytes, which establishes the address of the instruction  
following the stack and branch instruction, and a new location counter value.  
This value is the new instruction address, where processing continues.  

The exit function may return within a section or outside a section without  
any special consideration, since the stack contains the page and location of  
the return address.  

#### NOTE:

The Condition Register contains the true arithmetic condition (high  
or low) after an unsuccessful Jump (unequal condition).  

| Condition | Test |
| --------- | ----- |
| HIGH      | ACCUM > LITERAL    |
| LOW       | ACCUM < LITERAL   |
| EQUAL     | ACCUM = LITERAL    |

#### TIMING:  
3 Microseconds if the Jump is not performed.  
4 Microseconds if the Jump is performed.  

#### EXAMPLE:  

```
PPP-LLL:   MP1-MP2-MP3-MP4.   E SEQ. NO.   LAB:   VERB   OPERANDS     COMMENTS  
P15-016:   000-017.            02-090.      TLX, 000; (C).             EXIT IF  
P15-020:   000-013.            02-100.      TLX, 000; OCT:013.         ACCUM IS  
P15-022:   000-016.            02-110.      TLX, 000; DEC:014.         EQUAL  
P15-024:   000-377.            02-120.      TLX, 000; HEX:FF.  
```

---

### DPL-1 -- CLASS 0: JUMP -- TEST MASK AND EXIT -- TMX  

|      OBJECT      |          SOURCE            |  
|------------------|----------------------------|  
| 040-MMM          | TMX, 000; LT-MASK.         |  

WHERE: MMM is an 8 bit Literal Mask.  

#### DESCRIPTION:  

The state of the Accumulator bits selected by a mask is used to set the condition code.  

The byte of Immediate Data (Literal-Mask) is used as an eight-bit mask. The bits of the mask are made to correspond one for one with the bits of the character in the Accumulator. A mask bit of one indicates that the corresponding Accumulator bit is to be tested. When the mask bit is zero, the corresponding Accumulator bit is ignored. When any of the Accumulator bits thus selected are zero, the Condition Register is made unequal. When the selected bits are all one, the Condition Register is made equal. If the resulting Condition Register is equal, then a special form of exit, (conditional exit) is performed, which completes the return linkage established by the last executed stack and branch instruction. The stack pointer is decremented to the preceding stack level, which contains the address of the last stack and branch instruction executed. This address is then incremented by 2 bytes, which establishes the address of the instruction following the stack and branch instruction, and a new location counter value. This value is the new instruction address, where processing continues.  

The exit function may return within a section or outside a section without any special consideration, since the stack contains the page and location of the return address.  

#### NOTE:

The content of the Condition Register is unpredictable after an unsuccessful Jump (unequal condition).  

#### TIMING:  
3 Microseconds if the Jump is not performed.  
4 Microseconds if the Jump is performed.  

#### EXAMPLE:  

```
PPP-LLL:   MP1-MP2-MP3-MP4.   E SEQ. NO.   LAB:   VERB   OPERANDS     COMMENTS  
P15-026:   040-010.            02-180.      TMX, 000; OCT:010.         EXIT IF  
P15-030:   040-310.            02-190.      TMX, 000; DEC:200.         MASK IS  
P15-032:   040-240.            02-200.      TMX, 000; HEX:A0.          EQUAL  
```

---
## 3. CLASS 1: BRANCH

### DPL-1 -- CLASS 1: BRANCH -- BRANCH UNCONDITIONAL -- BRU

|      OBJECT      |          SOURCE            |  
|------------------|----------------------------|  
| 10X-XYX0         | BRU , RRR+NNN.             |  
|                  | BRU , Pnn; LLL.            |  
|                  |     ; *+NNN.               |  

WHERE: 10X is the command, in which  
X is the page.  

AND: XYX is a 7 bit address.  

WHERE: RRR is a symbolic address  
AND: NNN is a decimal byte displacement.  
AND: nn is a decimal page.  
AND: LLL is a decimal location.  
AND: * is the location of the instruction itself.  

#### DESCRIPTION:  

The unconditional branch is performed by introducing a branch address as a  
new instruction address, regardless of the setting of the Condition Register.  

The Branch Address may be represented in symbolic notation, as an absolute  
address; or as a relative address. The Branch Address may be any location within  
the current section. "OUT-OF-SECTION" branching is achieved by preceding the  
branch instruction with a SET MEMORY SECTION (SMS) instruction, or a SET memory  
SECTION & CONTROL (SSC) instruction. "WITHIN-A-PAGE" branching relocatability  
is achieved by preceding the branch instruction with a SET MEMORY CONTROL (SSC)  
instruction in which the RELOCATABLE BRANCH CONTROL (RBC) bit is set  
(i.e.: C#1 or C#3). The hardware condition register remains unchanged after  
execution of a branch function.  

#### TIMING:  
4 Microseconds.  

#### EXAMPLE:  

```
PPP-LLL:   MP1-MP2-MP3-MP4.   E SEQ. NO.   LAB:   VERB   OPERANDS     COMMENTS  
P15-034:   105-042.            03-030.      BRU; IN1.                 WITHIN A  
P15-036:   105-036.            03-040.      BRU; *+0.                  SECTION  
P15-040:   107-000.            03-050.      BRU; P15, 000.  
P15-042:   150-000.            03-060.      IN1; SMS; S#0.            OUT OF A  
P15-044:   106-144.            03-070.      BRU; P06, 100.             SECTION  
```

---

### DPL-1 -- CLASS 1: BRANCH -- BRANCH ON EQUAL -- BRE  

|      OBJECT      |          SOURCE            |  
|------------------|----------------------------|  
|                  | ; RRR+NNN.                  |  
| 10X-XYX1         | BRE , Pnn; LLL.             |  
|                  | ; *+NNN.                    |  

WHERE: 10X is the command, in which  
X is the page.  

AND: XYX is a 7 bit address.  

WHERE: RRR is a symbolic address.  
AND: NNN is a decimal byte displacement.  
AND: nn is a decimal page.  
AND: LLL is a decimal location.  
AND: * is the location of the instruction itself.  

#### DESCRIPTION:  

The conditional branch instruction, branch on equal, is performed when the condition register, set by a previous compare or test instruction, is found to be equal. If this condition is not satisfied, the next sequential instruction is executed. The conditional branch is performed by introducing a branch address as a new instruction address.  

(Refer to "BRU" for Basic Rules of Branching).  

#### TIMING:  
3 Microseconds if the branch is not performed.  
4 Microseconds if the branch is performed.  

#### EXAMPLE:  

```
PPP-LLL:   MP1-MP2-MP3-MP4.   E SEQ. NO.   LAB:   VERB   OPERANDS     COMMENTS  
P15-046:   105-051.            03-130.      BRE; IN2.                 WITHIN SECT.  
P15-050:   150-000.            03-140.      IN2; SMS; S#0.            OUT OF A  
P15-052:   340-200.            03-150.      CPA; R#0; OCT:200.        SECT. IF  
P15-054:   106-145.            03-160.      BRE; P06; 100.            EQUAL-ELSE  
P15-056:   150-010.            03-170.      SMS; S#1.                 RESET SECT.  
```

---

### DPL-1 -- CLASS 1: BRANCH -- BRANCH ON HIGH -- BRH  

|      OBJECT      |          SOURCE            |  
|------------------|----------------------------|  
|                  | ; RRR+NNN.                  |  
| 11X-XYX0         | BRH , Pnn; LLL.             |  
|                  | ; *+NNN.                    |  

WHERE: 11X is the command, in which  
X is the page.  

AND: XYX is a 7 bit address.  

WHERE: RRR is a Symbolic address.  
AND: NNN is a decimal byte displacement.  
AND: nn is a decimal page.  
AND: LLL is a decimal location.  
AND: * is the location of the instruction itself.  

#### DESCRIPTION:  

The conditional branch instruction, branch on high, is performed when the condition register, which has been set by a previous compare or test instruction, is found to be high. If this condition is not satisfied, the next sequential instruction is executed.  

(Refer to "BRU" for Basic Rules of Branching).  

#### TIMING:  
3 Microseconds if the branch is not performed.  
4 Microseconds if the branch is performed.  

#### EXAMPLE:  

```
PPP-LLL:   MP1-MP2-MP3-MP4.   E SEQ. NO.   LAB:   VERB   OPERANDS     COMMENTS  
P15-060:   115-062.            04-030.      BRH; *+02.                WITHIN SECT.  
P15-062:   150-000.            04-040.      IN3; SMS; S#0.            OUT OF A  
P15-064:   340-200.            04-050.      CPA; R#0; OCT:200.        SECT. IF  
P15-066:   116-144.            04-060.      BRH; P06; 100.            HIGH-ELSE  
P15-070:   150-010.            04-070.      SMS; S#1.                 RESET SECT.  
```

---

### DPL-1 -- CLASS 1: BRANCH -- BRANCH ON LOW -- BRL  


|      OBJECT      |          SOURCE            |  
|------------------|----------------------------|  
|                  | ; RRR+NNN.                  |  
| 11X-XYX1         | BRL , Pnn; LLL.             |  
|                  | ; *+NNN.                    |  

WHERE: 11X is the command, in which  
X is the page.  

AND: XYX is a 7 bit address.  

WHERE: RRR is a Symbolic address.  
AND: NNN is a decimal byte displacement.  
AND: nn is a decimal page.  
AND: LLL is a decimal location.  
AND: * is the location of the instruction itself.  

#### DESCRIPTION:  

The conditional branch instruction, branch on low, is performed when the condition register, set by a previous compare or test instruction, is found to be low. If this condition is not satisfied, the next sequential instruction is executed. The conditional branch is performed by introducing a branch address as a new instruction address.  

(Refer to "BRU" for Basic Rules of Branching)  

#### TIMING:  
3 Microseconds if the branch is not performed.  
4 Microseconds if the branch is performed.  

#### EXAMPLE:  

```
PPP-LLL:   MP1-MP2-MP3-MP4.   E SEQ. NO.   LAB:   VERB   OPERANDS     COMMENTS  
P15-072:   115-075.            04-130.           BRL; IN4.            WITHIN SECT.  
P15-074:   150-000.            04-140.      IN4: SMS; S#0.            OUT OF A  
P15-076:   340-200.            04-150.           CPA; R#0; OCT:200.   SECT. IF  
P15-100:   116-145.            04-160.           BRL; P06; 100.       LOW-ELSE  
P15-102:   150-010.            04-170.           SMS; S#1.            RESET SECT.  
```

---

### DPL-1 -- CLASS 1: BRANCH -- STACK AND BRANCH UNCONDITIONAL -- SBU  

|      OBJECT      |          SOURCE            |  
|------------------|----------------------------|  
|                  | ; RRR+NNN.                  |  
| 12X-XYX0         | SBU , Pnn; LLL.             |  
|                  | ; *+NNN.                    |  

WHERE: 12X is the command, in which  
X is the page.  

AND: XYX is a 7 bit address.  

WHERE: RRR is a symbolic address.  
AND: NNN is a decimal byte displacement.  
AND: nn is a decimal page.  
AND: LLL is a decimal location.  
AND: * is the location of the instruction itself.  

The Stack and Branch Unconditional Instruction is performed regardless of the setting of the condition register.  

#### DESCRIPTION:  

The stack and branch instructions are in contrast with the branch instructions, in that the stack and branch instructions preserve the current value of the location counter which is present in the current stack; this is performed by incrementing the stack pointer to the next stack level and creating a new location counter value containing the branch address as a new instruction address, within that stack. Thus, the return linkage between sub-routines is established. For the stack and branch function there are sixteen levels of stacks that the stack pointer can address, of which fifteen levels of stacks may temporarily preserve the return linkages for fifteen levels of stack and branching.  

#### TIMING:  
3 Microseconds  

#### EXAMPLE:  

```
PPP-LLL:   MP1-MP2-MP3-MP4.   E SEQ. NO.   LAB:   VERB   OPERANDS     COMMENTS  
P15-104:   125-112.            05-040.      SBU; IN5.                 WITHIN A  
P15-106:   125-112.            05-050.      SBU; *+04.                 SECTION  
P15-110:   127-000.            05-060.      SBU; P15; 000.  
P15-112:   150-000.            05-070.      IN5; SMS; S#0.            OUT OF A  
P15-114:   126-144.            05-080.      SBU; P06; 100.             SECTION  
```

---

#### DPL-1 -- CLASS 1: BRANCH -- STACK AND BRANCH ON EQUAL -- SBE  

|      OBJECT      |          SOURCE            |  
|------------------|----------------------------|  
|                  | ; RRR+NNN.                  |  
| 12X-XYX1         | SBE , Pnn; LLL.             |  
|                  | ; *+NNN.                    |  

WHERE: 12X is the command, in which  
X is the page.  

AND: XYX is a 7 bit address.  

WHERE: RRR is a symbolic address.  
AND: NNN is a decimal byte displacement.  
AND: nn is a decimal page.  
AND: LLL is a decimal location.  
AND: * is the location of the instruction itself.  

#### DESCRIPTION:  

The conditional stack and branch, stack and branch equal, is performed when the condition register, set by a previous compare or test instruction, is found to be equal. If the condition is not satisfied, the next sequential instruction is executed.  

(Refer to "SBU" for Basic Rules of Stack and Branching).  

#### TIMING:  
3 Microseconds if the stack and branch is not performed.  
4 Microseconds if the stack and branch is performed.  

#### EXAMPLE:  

```
PPP-LLL:   MP1-MP2-MP3-MP4.   E SEQ. NO.   LAB:   VERB   OPERANDS     COMMENTS  
P15-116:   125-121.            05-140.      SBE; *+02.                WITHIN SECT.  
P15-120:   150-000.            05-150.      IN6; SMS; S#0.            OUT OF A  
P15-122:   340-200.            05-160.      CPA; R#0; OCT:200.        SECTION IF  
P15-124:   126-145.            05-170.      SBE; P06; 100.            EQUAL-ELSE  
P15-126:   150-010.            05-180.      SMS; S#1.                 RESET SECT.  
```
---

### DPL-1 -- CLASS 1: BRANCH -- STACK AND BRANCH ON HIGH -- SBH  

·DPL-1              CLASS 1: BRANCH              STACK AND BRANCH ON HIGH  

|      OBJECT      |          SOURCE            |  
|------------------|----------------------------|  
|                  | ; RRR+NNN.                  |  
| 13X-XYX0         | SBH , Pnn; LLL.             |  
|                  | ; *+NNN.                    |  

WHERE: 13X is the command, in which  
X is the page.  

AND: XYX is a 7 bit address.  

WHERE: RRR is a symbolic address.  
AND: NNN is a decimal byte displacement.  
AND: nn is a decimal page.  
AND: LLL is a decimal location.  
AND: * is the location of the instruction itself.  

#### DESCRIPTION:  

The conditional stack and branch, stack and branch on high, is performed when the condition register, set by a previous compare or test instruction, is found to be high. If the condition is not satisfied the next sequential instruction is executed.  

(Refer to "SBU" for Basic Rules of Stack and Branching)  

#### TIMING:  
3 Microseconds if the stack and branch is not performed.  
4 Microseconds if the stack and branch is performed.  

#### EXAMPLE:  

```
PPP-LLL:   MP1-MP2-MP3-MP4.   E SEQ. NO.   LAB:   VERB   OPERANDS     COMMENTS  
P15-130:   135-132.            06-040.      SBH; IN7.                 WITHIN SECT.  
P15-132:   150-000.            06-050.      IN7; SMS; S#0.            OUT OF A  
P15-134:   340-200.            06-060.      CPA; R#0; OCT:200.        SECTION IF  
P15-136:   136-144.            06-070.      SBH; P06; 100.            HIGH-ELSE  
P15-140:   150-010.            06-080.      SMS; S#1.                 RESET-SECT.  
```

---

### DPL-1 -- CLASS 1: BRANCH -- STACK AND BRANCH ON LOW -- SBL  

|      OBJECT      |          SOURCE            |  
|------------------|----------------------------|  
|                  | ; RRR+NNN.                  |  
| 13X-XYX1         | SBL , Pnn; LLL.             |  
|                  | ; *+NNN.                    |  

WHERE: 13X is the command, in which  
X is the page.  

AND: XYX is a 7 bit address.  

WHERE: RRR is a symbolic address.  
AND: NNN is a decimal byte displacement.  
AND: nn is a decimal page.  
AND: LLL is a decimal location.  
AND: * is the location of the instruction itself.  

#### DESCRIPTION:  

The conditional stack and branch, stack and branch on low, is performed when the condition register, set by a previous compare or test instruction, is found to be low. If the condition is not satisfied the next sequential instruction is executed.  

(Refer to "SBU" for Basic Rules of Stack and Branching)  

#### TIMING:  
3 Microseconds if the stack and branch is not performed.  
4 Microseconds if the stack and branch is performed.  

#### EXAMPLE:  

```
PPP-LLL:   MP1-MP2-MP3-MP4.   E SEQ. NO.   LAB:   VERB   OPERANDS     COMMENTS  
P15-142:   135-145.            06-140.      SBL; IN8.                 WITHIN SECT.  
P15-144:   150-000.            06-150.      IN8; SMS; S#0.            OUT OF A  
P15-146:   340-200.            06-160.      CPA; R#0; OCT:200.        SECTION IF  
P15-150:   136-145.            06-170.      SBL; P06; 100.            LOW-ELSE  
P15-152:   150-010.            06-180.      SMS; S#1.                 RESET SECT.  
```

---

### DPL-1 -- CLASS 1: BRANCH -- EXIT AND BRANCH -- EXB

|      OBJECT      |          SOURCE            |  
|------------------|----------------------------|  
|                  | ; RRR+NNN.                  |  
| 16X-XYX0         | EXB , Pnn; LLL.             |  
|                  | ; *+NNN.                    |  

WHERE: 16X is the command, in which  
X is the page.  

AND: XYX is a 7 bit address.  

WHERE: RRR is a symbolic address.  
AND: NNN is a decimal byte displacement.  
AND: nn is a decimal page.  
AND: LLL is a decimal location.  

#### DESCRIPTION:  

The exit and branch instruction combines the functions of the exit instruction and the branch unconditional instruction. This form of exit does not perform the return linkage established by the preceding stack and branch instruction. The stack pointer is decremented to the preceding stack level. The address specified in the operand is then used to establish a new location counter value within that stack. This value is the new instruction address within the current section, where processing continues.  

#### TIMING:  
4 Microseconds  

#### EXAMPLE:  

```
PPP-LLL:   MP1-MP2-MP3-MP4.   E SEQ. NO.   LAB:   VERB   OPERANDS     COMMENTS  
P15-154:   165-156.            07-050.      EXB; *+02.                WITHIN SECT.  
P15-156:   150-000.            07-060.      SMS; S#0.                 OUT OF A  
P15-160:   166-144.            07-070.      EXB; P06; 100.            SECTION  
```

---

### DPL-1 -- CLASS 1: BRANCH -- EXIT UNCONDITIONAL -- EXU

|      OBJECT      |          SOURCE            |  
|------------------|----------------------------|  
| 140-000          | EXU; 000.                   |  

WHERE: 140 is the command.  
AND: 000 is the 8-Bit Operand  

#### DESCRIPTION:  

This form of exit, exit unconditional, performs the return linkage established by the last executed stack and branch instruction. The stack pointer is decremented to the preceding stack level, which contains the address of the last stack and branch instruction executed. This address is then incremented by 2 bytes which establishes the address of the instruction following the stack and branch instruction, and a new location counter value. This value is the new instruction address, where processing continues.  

The exit function may return within a section or outside a section without any special consideration, since the stack contains the page and location of the return address.  

The condition register is not changed by this instruction.  

#### TIMING:  
4 Microseconds.  

#### EXAMPLE:  

```
PPP-LLL:   MP1-MP2-MP3-MP4.   E SEQ. NO.   LAB:   VERB   OPERANDS     COMMENTS  
P15-162:   150-000.            07-130.      SMS; S#0.                 LINK OUT OF  
P15-164:   126-144.            07-140.      SBU; OUT.                 A SECTION  
                              *07-150.  
                               07-160.      ORG; P06; 100.  
P06-144:   213-006.            07-170.      OUT; LDA; I#3; P01.  
P06-146:   140-000.            07-180.      EXU; 000.                 RETURN  
```

---

### DPL-1 -- CLASS 1: BRANCH -- SET MEMORY SECTION -- SMS  

|      OBJECT      |          SOURCE            |  
|------------------|----------------------------|  
| 150-0X0          | SMS; S#X.                   |  

WHERE: X is the section number (0-7).  

#### DESCRIPTION:  

The set section instruction provides a means of transferring control from the current section to an outside section. A branch function (Branch, Stack & Branch or Exit & Branch) preceded by an SMS command will transfer control to the address defined by the branch address and the section specified in the set section operand.  

Note that once the SMS instruction has been executed, transfer to that section will only be made when an unconditional branch function is executed or a conditional branch function that is found to be true.  

The condition register is not changed by this instruction.  

#### TIMING:  
4 Microseconds.  

#### EXAMPLE:  

```
PPP-LLL:   MP1-MP2-MP3-MP4.   E SEQ. NO.   LAB:   VERB   OPERANDS     COMMENTS  
P15-000:   150-000.            08-070.      SMS; S#0.                 SET SECTION 0  
P15-002:   102-000.            08-080.      BRU; P02; 000.            BRANCH PAGE 2  
```

---

### DPL-1 -- CLASS 1 -- SET MEMORY CONTROL -- SMC  

|      OBJECT      |          SOURCE            |  
|------------------|----------------------------|  
| 151-Y00          | SMC; C#Y.                   |  

WHERE:  
Y = 0 Resets U & V control bits,  
Y = 1 Sets V Bit, Resets U Bit,  
Y = 2 Sets U Bit, Resets V Bit,  
Y = 3 Sets U and V Bits.  

#### DESCRIPTION:  

When the U bit is set to 0, the address of the index registers is memory location 1-7 and direct addressing is only available in page 0 of section 0. When the U bit is set to 1, the effective index register address is location 1-7 of the section where the indexed instruction is being executed. Likewise the effective direct address is page 0 of the section where the direct address instruction is being executed.  

When the V bit is set to 1 any branch, stack & branch or exit & branch instructions given with page 0 specified in the branch address will cause the branch to occur within the current section and page of the program. If any page other than 0 is specified in the branch address, the V bit control is inactive and a normal branch will occur. For example, assume that the V bit is set and a branch instruction located in page 5 specifies a branch to page 0 location AAA. The resulting branch will be, to page 5 location AAA. If the branch address specified was page 6 location BBB, then the resulting branch will be to page 6 location BBB. If a program resides in any page other than page 0 and a branch to page 0 is desired, the V bit must be inactive.  

An exit or exit and branch operation will restore the control bits to the value associated with that stack level. A stack and branch operation will not affect the control bits.  

#### TIMING:  
4 Microseconds.  

#### EXAMPLE:  

```
PPP-LLL:   MP1-MP2-MP3-MP4.   E SEQ. NO.   LAB:   VERB   OPERANDS     COMMENTS  
P15-004:   151-300.            08-140.      SMC; C#3.                 SET U,V CONTROL  
P15-006:   230-200.            08-150.      STA; R#0; 128.            STORE PAGE 10  
P15-010:   100-100.            08-160.      BRU; P00; 064.            BRANCH TO  
                              *08-170.                                PAGE 15-100/OCT  
```

---

### DPL-1 -- CLASS 1 -- SET MEMORY SECTION & CONTROL -- SSC  

|      OBJECT      |          SOURCE            |  
|------------------|----------------------------|  
| 152-YX0          | SSC, S#X; C#Y               |  

WHERE: X is the section designation  
Y is the control bit designation  

#### DESCRIPTION:  

This instruction performs both the set memory section operation of SMS and set memory control operation of SMC.  

#### TIMING:  
4 Microseconds.  

#### EXAMPLE:  

```
PPP-LLL:   MP1-MP2-MP3-MP4.   E SEQ. NO.   LAB:   VERB   OPERANDS     COMMENTS  
P15-012:   152-030.            09-030.      SSC, S#3; C#0.            SET SECT. 3 &  
                               09-040.                                RESET U & V-BIT  
P15-014:   152-360.            09-050.      SSC, S#6; C#3.            SET SECT. 6 &  
                              *09-060.                                SET U & V-BITS  
```

---

### DPL-1 -- CLASS 1 -- SET ARITHMETIC CONDITION -- SAC  

|      OBJECT      |          SOURCE            |  
|------------------|----------------------------|  
| 153-000          | SAC; 000.                   |  

#### DESCRIPTION:  

This instruction will force the arithmetical condition registers of the processor to an equal, high or low condition, dependent upon the state of bits 4 and 5 of the accumulator at the time of the SAC instruction.  

The condition forced by the SAC instruction for a given state of bits 4 and 5 of the ACC is given below.  

ACCUMULATOR BITS  

| 7 6 5 4 3 2 1 0 | CONDITION FORCED |  
|-----------------|------------------|  
| 1 0             | Equal            |  
| 0 1             | High             |  
| 0 0             | Low              |  
| 1 1             | Equal            |  

#### TIMING:  
4 Microseconds.  

#### EXAMPLE:  

```
PPP-LLL:   MP1-MP2-MP3-MP4.   E SEQ. NO.   LAB:   VERB   OPERANDS     COMMENTS  
P15-016:   200-020.            09-120.      LDA; R#0; OCT:020.        LOAD COND. CODE  
P15-020:   153-000.            09-130.      SAC; 000.                 SET COND. HIGH  
```

---

### DPL-1 -- CLASS 1 -- LOAD SENSE SWITCHES -- LSW  

|      OBJECT      |          SOURCE            |  
|------------------|----------------------------|  
| 154-000          | LSW; 000.                   |  

#### DESCRIPTION:  

The load sense switch instruction will load the state of 8 toggle switches (located in the switch well under the CRT screen) to the accumulator. Switch 0 is loaded to ACC Bit 0, switch 1 to ACC Bit 1, etc.  

#### TIMING:  
4 Microseconds.  

#### EXAMPLE:  

```
PPP-LLL:   MP1-MP2-MP3-MP4.   E SEQ. NO.   LAB:   VERB   OPERANDS     COMMENTS  
P15-022:   154-000.            09-190.      LSW; 000.                 LOAD S.S.  
P15-024:   044-004.            09-200.      TMJ, +04; OCT:004.        TEST SW. #2  
```

---

### DPL-1 -- CLASS 1 -- LOAD PROCESSOR STATUS -- LPS  

|      OBJECT      |          SOURCE            |  
|------------------|----------------------------|  
| 155-000          | LPS; 000.                   |  

#### DESCRIPTION:  

This instruction loads a processor status word into the accumulator. The following shows the accumulator bits and their respective meaning.  

```
  ACCUMULATOR  
7 6 5 4 3 2 1 0
- - --- -------
```


- **Bit 7**: Program Interrupt Switch  
  (This bit is set whenever the program interrupt switch is in the interrupt position. It is reset whenever the interrupt switch is in the neutral position. Therefore, this switch could also be used as a sense switch.)  

- **Bit 6**: Interrupt Overflow (See EPI Instruction)  

- **Bit 5-4**: Arithmetic Condition Register (See SAC Instruction)  

- **Bits 3-0**: Stack Pointer Address (Level 0 to 15)  


```
STACK LEVEL   0   1   2   3   4   5   6   7    
            +---+---+---+---+---+---+---+---+  
            |L:P| : | : | : |1:0| : | : | : |
            |O:A| : | : | : |1:1| : | : | : |
            |C:G| : | : | : |7:0| : | : | : |
            | :E| : | : | : |   | : | : | : |
            +---+---+---+---+---+---+---+---+  
PAGE 0 LOC. 40  42  44  46  50  52  54  56  60  
                                -----
                               CURRENT
                                STACK
```

#### TIMING:  
4 microseconds  

#### EXAMPLE:  

```
PPP-LLL:   MP1-MP2-MP3-MP4.   E SEQ. NO.   LAB:   VERB   OPERANDS     COMMENTS  
                              *10-050.      CALCULATE ADD.OF LAST STACK & BRANCH INST.  
P15-026:   155-000.            10-060.      LPS; 000.                 CALCULATE ADDR.  
P15-030:   307-036.            10-070.      SAN; S#7; OCT:036.        OF CURRENT  
P15-032:   360-040.            10-080.      IRA; R#0; OCT:040.        STACK (LOC.)  
P15-034:   230-001.            10-090.      STA; R#0; R#1.            SAVE IN R#1  
P15-036:   261-002.            10-100.      SUX; R#1; OCT:002.        PREVIOUS STK LV  
P15-040:   211-000.            10-110.      LDX; I#1; P00.            RETRIEVE LOC.  
P15-042:   300-376.            10-120.      ANA; R#0; OCT:376.        FROM PRIOR STK  
P15-044:   230-002.            10-130.      STA; R#0; R#2.            REMOVE LO BIT  
P15-046:   211-000.            10-140.      LDA; R#1; P00.            RETRIEVE PAGE  
P15-050:   306-377.            10-150.      SAN; S#6; OCT:377.        OCTAL FORM-SHFT  
P15-052:   230-003.            10-160.      STA; R#0; R#3.            FOR DPL PG R-FM  
```

---

### DPL-1 -- CLASS 1 -- DISABLE PROCESSOR INTERRUPT -- DPI  

|      OBJECT      |          SOURCE            |  
|------------------|----------------------------|  
| 156-000          | DPI; 000.                   |  

#### DESCRIPTION:  

The disable processor interrupt instruction will inhibit the auto stack and branch that occurs upon receipt of an interrupt. It does not disable the interrupt.  

If the Disable Processor Interrupt (DPI) was executed prior to the Enable Processor Interrupt (EPI) Instruction, and the interrupt is activated, the interrupt will occur only immediately following the execution of an EPI instruction.  

#### TIMING:  

4 Microseconds.  

---

### DPL-1 -- CLASS 1 -- ENABLE PROCESSOR INTERRUPT -- EPI

|      OBJECT      |          SOURCE            |  
|------------------|----------------------------|  
| 156-001          | EPI; 000.                   |  

#### DESCRIPTION:  

Within the SYSTEM 4 hardware structure, there are two mechanisms which provide for the interrupting of normal instruction processing.  

One is designed primarily for use by the programmer. The Interrupt Switch is located in the Switch Well under the CRT screen and can be activated by pushing the PROGRAM LOAD Toggle Switch in the opposite direction of the PROGRAM LOAD. Another interrupt cannot be generated until the switch is moved to the off position and then on again. Also an external interrupt will not be effective unless the interrupt switch is off. Two levels of interrupts may be preserved by the interrupt logic prior to the execution of an Enable Processor Interrupt (EPI) Instruction. Additional interrupts will cause the interrupt overflow indicator to be set (see 'LPS' Instruction).  

An external interrupt input is provided for use by external devices. This is activated by a pulse from an external device.  

For each interrupt (external or program) an EPI Instruction must be previously executed. After execution, that level of interrupt will be reset. If the interrupt is activated after the execution of the Enable Processor Interrupt (EPI) Instruction, an automatic Stack and Branch operation to Section 0, Page 3, Location 000 will occur. Therefore, the user program to process the interrupt condition must be initialized in Page 03-000. The return to the point of interrupt can be effected by an Exit (EXU) instruction to that Stack level. (Refer to Stack and Branch Unconditional).  

#### NOTE:

If the Disable Processor Interrupt (DPI) was not executed prior to the Enable Processor Interrupt (EPI) Instruction, and the interrupt is activated, the interrupt will occur after the execution of the current instruction.  

#### INTERRUPT LOCK OUT  

An interrupt will not occur during any of the following conditions. However, they do not inhibit the interrupt, they simply delay the auto Stack and Branch until the condition is completed. These conditions are:  

1) Tape movement (Read/Write/Rewind/Search)  

2) If the keyboard is made ready (i.e. by depressing a key and a Read from the keyboard has not been executed). In this case, the interrupt will occur immediately following the keyboard Read Instruction.  

3) During a Set Section or Set Section and Control operation.  

4) Interrupt Disable has been set (see Disable Processor Interrupt (DPI) Instruction).  

#### TIMING:  

4 Microseconds.  


---

### DPL-1 -- CLASS 1 -- CLEAR PROCESSOR INTERRUPT -- CPI  

|      OBJECT      |          SOURCE            |  
|------------------|----------------------------|  
| 156-002          | CPI; 000.                   |  

#### DESCRIPTION:  

An interrupt overflow condition occurs when more than two interrupts have been activated before the execution of an Enable Processor Interrupt (EPI) instruction. This condition may be tested through the use of the Load Processor Status (LPS) Instruction.  

By execution of a Clear Interrupt instruction, the interrupt overflow indicator will be cleared.  

#### TIMING:  
4 Microseconds.  


---

## 4. CLASS 2: TRANSFER

### DPL-1 -- CLASS 2: DATA TRANSFER -- LOAD ACCUMULATOR -- LDA

|      OBJECT      |          SOURCE            |  
|------------------|----------------------------|  
| 200-LLL          | LDA, R#0; Literal.          |  
| 210-YXX          | LDA, R#0; AAA+NNN.          |  
| 211-YXZ0         | LDA, R#X; PPP.               |  
| 211-YXZ1 0       | LDA, I#X; PPP.               |  
| 211-YXZ1 1       | LDA, D#X; PPP.               |  
| 211-YXZ0p        | LDA, R#X; AAA+NNN.           |  

WHERE:  
- 200 is an immediate address command.  
- LLL is any form of literal notation.  
- 210 is a direct address command.  
- YXX is an 8-bit location address within a level zero page.  
- 211 is an indexed address command.  
- I is any register (1-7).  
- YXZ is a 6-bit base page address.  

WHERE:  
- R#0 is the immediate or direct indicator.  
- AAA is a direct address page within level #0.  
- NNN is a decimal byte displacement.  
- X is any register (1-7).  
- PPP is a decimal page notation.  
- I = Increment register by 001 after execution.  
- D = Decrement register by 001 after execution.  
- R = Register value unchanged after execution.  

#### DESCRIPTION:  

Load the Accumulator with the value specified by the immediate, the direct or the indexed address. The immediate form of this instruction provides the means of specifying machine values or bit configurations as part of the instruction. Literal terms may be used to specify such program elements as immediate data, masks, and addresses. The direct form of this instruction allows the user to directly address any level zero page. By supplying the base page as the operand and by specifying the index register containing the address displacement within that page, the user can address any location within the memory.  

The condition register value remains unchanged after execution of this instruction.  

#### TIMING:  
- 4 Microseconds when literal form is used.  
- 6 Microseconds when literal form is not used.  

#### EXAMPLE:  

```
PPP-LLL:   MP1-MP2-MP3-MP4.   E SEQ. NO.   LAB:   VERB   OPERANDS     COMMENTS  
P15-054:   200-200.            11-030.      LDA, R#0; OCT:200.        IMMEDIATE  
P15-056:   200-066.            11-040.      LDA, R#0; ADL:AAA.        ADDRESSING  
P15-060:   200-064.            11-050.      LDA, R#0; ADP:AAA.        ADDRESSING  
                              *11-060.  
P15-062:   210-200.            11-070.      LDA, R#0; 128.            DIRECT  
P15-064:   210-007.            11-080.      LDA, R#0; R#7.            ADDRESSING  
                              *11-090.  
P15-066:   213-040.            11-100.      AAA: LDA, R#3; P00.       INDEXED  
P15-070:   213-042.            11-110.      LDA, I#3; P00.            ADDRESSING  
P15-072:   213-043.            11-120.      LDA, D#3; P00.            ADDRESSING  
```


---

### DPL-1 -- CLASS 2: DATA TRANSFER -- LOAD INDEX REGISTER -- LDX  

|      OBJECT      |          SOURCE            |  
|------------------|----------------------------|  
| 20I-LLL          | LDX, R#X; Literal.          |  

WHERE: I is any register (1-7).  
AND: LLL is any form of literal notation.  

#### DESCRIPTION:  

Load the specified index register with the value indicated by the immediate address. The primary use of this instruction is to establish the address displacement, within a page, for the indexed addressing instructions. Any form of literal notation may be used.  

The condition register value remains unchanged after execution of this instruction.  

#### TIMING:  
4 Microseconds  

#### EXAMPLE:  

```
PPP-LLL:   MP1-MP2-MP3-MP4.   E SEQ. NO.   LAB:   VERB   OPERANDS     COMMENTS  
P15-074:   201-017.            11-180.      LDX, R#1; OCT:017.  
P15-076:   202-017.            11-190.      LDX, R#2; DEC:015.  
P15-100:   203-017.            11-200.      LDX, R#3; HEX:0F.  
P15-102:   204-017.            12-010.      LDX, R#4; (C).  
P15-104:   205-110.            12-020.      LDX, R#5; ADL:BBB.  
P15-106:   206-102.            12-030.      LDX, R#6; BBB:P06.  
P15-110:   207-066.            12-040. BBB: LDX, R#7; IDP:BBB.  
```

---

### DPL-1 -- CLASS 2 -- LOAD INSTRUCTION ADDRESS -- LIA  

|      OBJECT      |          SOURCE            |  
|------------------|----------------------------|  
| 221-000          | LIA, R#X; 000.              |  
| 221-LLL          | LIA, R#X; Literal.          |  

WHERE: I is any register (1-7)  
AND: LLL is any form of Literal Notation.  

#### DESCRIPTION:  

This instruction will transfer the 8 least significant bits of the current instruction address to the specified index register. If the instruction literal is 000, then the section and page of the current instruction address is transferred to the accumulator. If the literal is not 000, then the literal is transferred to the accumulator.  

#### TIMING:  
4 Microseconds  

#### EXAMPLE:  

```
PPP-LLL:   MP1-MP2-MP3-MP4.   E SEQ. NO.   LAB:   VERB   OPERANDS     COMMENTS  
                               *12-100.    LOAD INSTRUCTION ADDRESS (MAIN ROUTINE)  
                               *12-110.    MONITOR, FIXED, NON-RELOCATABLE.  
                               *12-120.  
P15-112:   151-200.             12-130.         SMC;  C#2.            SET CONTROL  
P15-114:   201-123.             12-140.    MTR: LDX,  R#1; MTR+P07.   SET POINTER  
P15-116:   231-064.             12-150.         STA,  R#1; MTR.       (ACCUM CONTAINS  
                               *12-160.                               PAGE NUMBER)
P15-120:   210-006.             12-170.         LDA,  R#0; R#6.       DATA PAGE  
P15-122:   237-000.             12-180.         STA,  R#7; P00.       INSERT PAGE  
P15-124:   140-000.             12-190.         EXU;  000.  
                               *12-200.
                               *13-010.    RELOCATABLE SUBROUTINE.  
                                13-020.         ORG:  P14, 000.       ACM.CONTAINS PG  
P16-000:   227-000.             13-030.    SUB: LIA,  R#7; 000.       R#(-ADDR + 1)  
P16-002:   247-006.             13-040.         ADX,  R#7; OCT:006.   ADJUST  
P16-004:   125-114.             13-050.         SBU;  MTR.  
P16-006:   354-002.             13-060.    SBI: CPA,  I#4; P00.       PAGE CHANGED  
                               *13-070.                               AT OBJECT-TIME
```

---

### DPL-1 -- CLASS 2: DATA TRANSFER -- STORE ACCUMULATOR -- STA  

|      OBJECT      |          SOURCE            |  
|------------------|----------------------------|  
| 230-YXX          | STA, R#0; AAA+NNN.          |  
| 231-YXZ0         | STA, R#X; PPP.               |  
| 231-YXZ1 0       | STA, I#X; PPP.               |  
| 231-YXZ1 1       | STA, D#X; PPP.               |  
| 231-YXZ0p        | STA, R#X; AAA+NNN.           |  

WHERE:  
- 230 is a direct address command.  
- YXX is an 8-bit location address within a level zero page.  
- 231 is an indexed address command.  
- I is any index (1-7).  
- YXZ is a 6-bit base page address.  

WHERE:  
- AAA is a direct address page within level #0.  
- NNN is a decimal byte displacement.  
- X is any register (1-7).  
- PPP is a decimal page notation.  
- I = Increment register by 001 after execution.  
- D = Decrement register by 001 after execution.  
- R = Register value unchanged after execution.  

#### DESCRIPTION:  

Store the contents of the Accumulator into the address specified by the direct or indexed address contained in the instruction operand. The direct form of this instruction allows the user to directly address any location within a level zero page. By supplying the base page address as the operand and by specifying the index register containing the address displacement within that page, the user can address any location within the memory, thus performing the function of indexed addressing.  

The condition register value remains unchanged after execution of this instruction.  

#### TIMING:  

6 Microseconds.  

#### EXAMPLE:  

```
PPP-LLL:   MP1-MP2-MP3-MP4.   E SEQ. NO.   LAB:   VERB   OPERANDS     COMMENTS  
P16-010:   230-144.            13-140.       STA, R#0; 100.           DIRECT  
P16-012:   230-007.            13-150.       STA, R#0; R#7.           ADDRESSING  
                              *13-160.  
P16-014:   231-070.            13-170.       STA, R#1; OCC.           INDEXED  
P16-016:   231-037.            13-180.       STA, D#1; P07.           ADDRESSING  
P16-020:   231-036.            13-190.  CCC: STA, I#1; P07.             
```

---

## 5. CLASS 2: ORDINARY ARITHMETIC

### DPL-1 -- CLASS 2: ARITHMETIC -- ADD TO ACCUMULATOR -- ADA  

|      OBJECT      |          SOURCE            |  
|------------------|----------------------------|  
| 240-LLL          | ADA, R#0; Literal.          |  
| 250-YXX          | ADA, R#0; AAA+NNN.          |  
| 251-YXZ0         | ADA, R#X; PPP.               |  
| 251-YXZ1 0       | ADA, I#X; PPP.               |  
| 251-YXZ1 1       | ADA, D#X; PPP.               |  

WHERE:  
- 240 is an immediate address command.  
- LLL is any form of literal notation.  
- 250 is a direct address command.  
- YXX is an 8-bit location address within a level zero page.  
- 251 is an indexed address command.  
- I is any index (1-7).  
- YXZ is a 6-bit base page address.  

WHERE:  
- R#0 is the immediate or direct indicator.  
- AAA is a direct address page within level #0.  
- NNN is a decimal byte displacement.  
- X is any register (1-7).  
- PPP is a decimal page notation.  
- I = Increment register by 001 after execution.  
- D = Decrement register by 001 after execution.  
- R = Register value remains unchanged after execution.  

#### DESCRIPTION:  

Binary add to the Accumulator the value specified by the immediate, the direct, or the indexed address. The immediate form of this instruction provides the means of specifying machine values or bit configurations as part of the instruction. The direct form of this instruction allows the user to directly address any level zero page. By supplying the base page address as the operand and by specifying the index register containing the address displacement within that page, the user can address any location within the memory, thus performing the function of indexed addressing. In the event of an overflow condition, the overflow character is lost.  

The condition register value remains unchanged after execution of this instruction.  

#### TIMING:  
- 4 Microseconds when literal form is used.  
- 6 Microseconds when literal form is not used.  

#### EXAMPLE:  

```
PPP-LLL:   MP1-MP2-MP3-MP4.   E SEQ. NO.   LAB:   VERB   OPERANDS     COMMENTS  
P16-022:   240-004.            14-060.  DDD: ADA, R#0; (1).            ADD IMMEDIATE  
P16-024:   250-007.            14-070.      ADA, R#0; R#7.             ADD DIRECT  
P16-026:   253-004.            14-080.      ADA, R#3; P01.             ADD INDEXED  
P16-030:   253-072.            14-090.      ADA, I#3; DDD.  
P16-032:   253-007.            14-100.      ADA, D#3; P01.  
```

---

### DPL-1 -- CLASS 2: ARITHMETIC -- ADD TO INDEX REGISTER -- ADX

|      OBJECT      |          SOURCE            |  
|------------------|----------------------------|  
| 241-LLL          | ADX, R#X; Literal.          |  

WHERE:  
- I is any register (1-7)  
- LLL is any form of literal notation.  

#### DESCRIPTION:  

Binary add to the index register specified, the value indicated by the immediate address. In the event of any overflow condition, the overflow character is lost.  

The condition register value remains unchanged after execution of this instruction.  

#### TIMING:  
4 Microseconds.  

#### EXAMPLE:  

```
PPP-LLL:   MP1-MP2-MP3-MP4.   E SEQ. NO.   LAB:   VERB   OPERANDS     COMMENTS  
P16-034:   241-004.            14-160.  EEE: ADX, R#1; (1).            BINARY ADD  
P16-036:   242-004.            14-170.      ADX, R#2; OCT:004.         TO INDEX  
P16-040:   243-372.            14-180.      ADX, R#3; HEX:FA.          REGISTER  
```

---

### DPL-1 -- CLASS 2: ARITHMETIC -- SUBTRACT FROM ACCUMULATOR -- SUA  

|      OBJECT      |          SOURCE            |  
|------------------|----------------------------|  
| 260-LLL          | SUA, R#0; Literal.          |  
| 270-YXX          | SUA, R#0; AAA+-NNN.          |  
| 271-YXZ0         | SUA, R#X; PPP.               |  
| 271-YXZ1 0       | SUA, I#X; PPP.               |  
| 271-YXZ1 1       | SUA, D#X; PPP.               |  

WHERE:  
- 260 is an immediate address command.  
- LLL is any form of literal notation.  
- 270 is a direct address command.  
- YXX is an 8-bit location address within a level zero page.  
- 271 is an indexed address command.  
- I is any index (1-7).  
- YXZ is a 6-bit base page address.  

WHERE:  
- R#0 is the immediate or direct indicator.  
- AAA is a direct address page within level #0.  
- NNN is a decimal byte displacement.  
- X is any register (1-7).  
- PPP is a decimal page notation.  
- I = Increment register by 001 after execution.  
- D = Decrement register by 001 after execution.  
- R = Register value remains unchanged after execution.  

### DESCRIPTION:  

Binary subtract from the Accumulator, the value specified by the immediate, the direct or the indexed address. The immediate form of the instruction provides the means of specifying machine values or bit configuration as part of the instruction. The direct form of this instruction allows the user to directly address any location within a level zero page. By supplying the base page address as the operand and by specifying the index register containing the address displacement within that page, the user can address any location within the memory, thus performing the function of indexed addressing. The two's complement results from an underflow condition. The condition register value remains unchanged after execution of this instruction.  

### TIMING:  
- 4 Microseconds when literal form is used.  
- 6 Microseconds when literal form is not used.  

### EXAMPLE:  

```
PPP-LLL:   MP1-MP2-MP3-MP4.   E SEQ. NO.   LAB:   VERB   OPERANDS     COMMENTS  
P16-042:   260-004.            15-040.      SUA, R#0; (1).             SUB. IMMED.  
P16-044:   270-007.            15-050.  FFF: SUA, R#7.                  SUB. DIRECT  
P16-046:   273-004.            15-060.      SUA, R#3; P01               SUB. INDEXED  
P16-050:   273-070.            15-070.      SUA, R#3; FFF.  
```

---

### DPL-1 -- CLASS 2: ARITHMETIC -- SUBTRACT FROM INDEX REGISTER -- SUX  

|      OBJECT      |          SOURCE            |  
|------------------|----------------------------|  
| 261-LLL          | SUX, R#X; Literal.          |  

WHERE:  
- I is any register (1-7).  
- LLL is any form of literal notation.  

#### DESCRIPTION:  

Binary subtract from the index register specified, the value indicated by the immediate address. The two's complement results from an underflow condition. The condition register value remains unchanged after execution of this instruction.  

#### TIMING:  
4 Microseconds.  

#### EXAMPLE:  

```
PPP-LLL:   MP1-MP2-MP3-MP4.   E SEQ. NO.   LAB:   VERB   OPERANDS     COMMENTS  
P16-052:   261-004.            15-130.  GGG: SUX, R#1; (1).            BINARY  
P16-054:   262-004.            15-140.      SUX, R#2; OCT:004.         SUBTRACT FROM  
P16-056:   262-017.            15-150.      SUX, R#2; HEX:0F.          INDEX REG.  
P16-060:   263-144.            15-160.      SUX, R#3; DEC:100.  
```


## 6. CLASS 3: BOOLEAN ARITHMETIC

### DPL-1 -- CLASS 3: BOOLEAN -- LOGICAL "AND" TO ACCUMULATOR -- ANA

|      OBJECT      |          SOURCE            |  
|------------------|----------------------------|  
| 300-LLL          | ANA, R#0; Literal.          |  
| 310-YXX          | ANA, R#0; AAA+NNN.          |  
| 311-YXZ0         | ANA, R#X; PPP.               |  
| 311-YXZ1 0       | ANA, I#X; PPP.               |  
| 311-YXZ1 1       | ANA, D#X; PPP.               |  

WHERE:  
- 300 is an immediate address command.  
- LLL is any form of literal notation.  
- 310 is a direct address command.  
- YXX is an 8-bit location address within a level zero page.  
- 311 is an indexed address command.  
- I is an index (1-7).  
- YXZ is a 6-bit base page address.  

WHERE:  
- R#0 is the immediate or direct indicator.  
- AAA is a direct address page within level #0.  
- NNN is a decimal byte displacement.  
- X is any register (1-7).  
- PPP is a decimal page notation.  
- I = Increment register by 001 after execution.  
- D = Decrement register by 001 after execution.  
- R = Register value remains unchanged after execution.  

#### DESCRIPTION:  

Logical "and" to the Accumulator the value specified by the immediate, direct or indexed addresses. The immediate form of this instruction provides the means of specifying machine values of bit configurations as part of the instruction. The direct form of this instruction allows the user to directly address any level zero page. By supplying the base page address as the operand and by specifying the index register containing the address displacement within that page, the user can address any location within the memory, thus performing the function of indexed addressing. The value of the operand is treated as an unstructured logical quantity, and the value is applied bit by bit to the Accumulator. The bit position in the result (Accumulator) is set to one if the corresponding bit positions in the Accumulator and the operand both contain a one; otherwise, the result bit is set to zero. (Result is one if both are ones). All operand values and results are valid. The condition register value remains unchanged after execution of this instruction.  

#### TIMING:  
- 4 Microseconds when literal form is used.  
- 6 Microseconds when literal form is not used.  

#### EXAMPLE:  

```
PPP-LLL:   MP1-MP2-MP3-MP4.   E SEQ. NO.   LAB:   VERB   OPERANDS     COMMENTS  
P16-026:   300-026.           *16-020.     LOGICAL "AND" TO ACCUMULATOR.  
P16-026:   310-007.            16-030.     ANA, R#0; OCT:026.           IMMEDIATE  
P16-062:   314-P03.            16-040.     ANA, R#0; R#7.                DIRECT  
P16-067:   314-P03.            16-050.     ANA, R#4; P06.                INDEXED  
P16-072:   314-P32.            16-060.     ANA, I#4; P06.                ADDRESSING  
P16-074:   314-P36.            16-070.     ANA, D#4; P06.  
```

---

### DPL-1 -- CLASS 3: BOOLEAN -- SHIFT & LOGICAL "AND" TO ACCUMULATOR -- SAN

|      OBJECT      |          SOURCE            |  
|------------------|----------------------------|  
| 30I-LLL          | SAN, S#X; Literal.          |  

WHERE:  
- I is the bit shift count (1-7).  
- LLL is any literal notation.  

WHERE:  
- X is the bit shift count (1-7).  

#### DESCRIPTION:  

This form of the logical "and" instruction performs a right circular shift of the bits in the Accumulator, by the number of bits specified in the shift counter before the logical "and" of the literal to the Accumulator is performed.  

All literal values and results are valid. The condition register value remains unchanged after the execution of this instruction.  

#### TIMING:  
4 Microseconds.  

#### EXAMPLE:  

```
PPP-LLL:   MP1-MP2-MP3-MP4.   E SEQ. NO.   LAB:   VERB   OPERANDS     COMMENTS  
                             *16-120.     SHIFT AND LOGICAL "AND" TO ACCUMULATOR.  
P16-074:   303-026.           16-130.     SAN, S#3; OCT:026.  
```

```
1 1 0 0 0 1 0 1    Initial Accumulator Value
\_______/ \___/
    |       |
  +-|-------+
  | |
  | +-----+
  |       |
/---\ /-------\
1 0 1 1 1 0 0 0    Initial Accumulator Value after a Shift of 3
0 0 0 1 0 1 1 0    Literal Value
0 0 0 1 0 0 0 0    Accumulator Value after the logical "AND" of OCT:026
```

---

### DPL-1 -- CLASS 3: BOOLEAN -- EXCLUSIVE "OR" TO ACCUMULATOR -- ERA

|      OBJECT      |          SOURCE            |  
|------------------|----------------------------|  
| 320-LLL          | ERA, R#0; Literal.          |  
| 330-YXX          | ERA, R#0; AAA+NNN.          |  
| 331-YXZ00        | ERA, R#X; PPP.              |  
| 331-YXZ10        | ERA, I#X; PPP.              |  
| 331-YXZ11        | ERA, D#X; PPP.              |  

WHERE:  
- 320 is an immediate address command.  
- LLL is any form of literal notation.  
- 330 is a direct address command.  
- YXX is an 8-bit location address within a level zero page.  
- 33I is an indexed address command.  
- I is any index (1-7).  
- YXZ is a 6-bit base page address.  

WHERE:  
- R#0 is the immediate or direct indicator.  
- AAA is a direct address page within level zero.  
- NNN is a decimal byte displacement.  
- X is any register (1-7).  
- PPP is a decimal page notation.  
- I-Increment register by 001 after execution.  
- D-Decrement register by 001 after execution.  
- R-Register value remains unchanged after execution.  

#### DESCRIPTION:  

Exclusive "or" to the Accumulator the value specified by the immediate, direct or indexed address. The immediate form of this instruction provides the means of specifying machine values or bit configurations as part of the instruction. The direct form of this instruction allows the user to directly address any level zero page. By supplying the base page address as the operand and by specifying the index register containing the address displacement within that page, the user can address any location within the memory. The value of the operand is treated as an unstructured logical quantity, and the value is applied bit by bit to the Accumulator. A bit position in the result (Accumulator) is set to one if the corresponding bit positions in the accumulator and as specified by the operand, are unlike; otherwise, the result bit is set to zero. (Result is one if unlike). All operand values and results are valid. The condition register value remains unchanged after execution of this instruction.  

#### TIMING:  
4 Microseconds when literal form is used.  
6 Microseconds when literal form is not used.  

#### EXAMPLE:  

```
PPP-LLL:   MP1-MP2-MP3-MP4.   E SEQ. NO.   LAB:   VERB   OPERANDS     COMMENTS  
                              *17-060.     EXCLUSIVE "OR" TO ACCUMULATOR  
P16-076:   320-026.            17-070.     ERA, R#0; OCT:026.     IMMEDIATE  
P16-100:   330-007.            17-080.     ERA, R#0; R#7.        DIRECT  
P16-102:   33I-030.            17-090.     ERA, R#4; P06.        INDEXED  
P16-104:   33I-032.            17-100.     ERA, I#4; P06.        ADDRESSING  
P16-106:   33I-033.            17-110.     ERA, D#4; P06.  
```

---

### DPL-1 -- CLASS 3: BOOLEAN -- SHIFT & EXCLUSIVE "OR" TO ACCUMULATOR -- SER

|      OBJECT      |          SOURCE            |  
|------------------|----------------------------|  
| 32I-LLL          | SER, S#X; Literal.          |  

WHERE:  
- I is the bit shift count (1-7).  
- LLL is any literal notation.  

WHERE:  
- X is the bit shift count (1-7).  

#### DESCRIPTION:  

This form of the exclusive "or" instruction performs a right circular shift of the bits in the Accumulator, by the number of bits specified in the shift counter, before the exclusive "or" of the literal to the Accumulator is performed.  

All literal values and results are valid. The condition register value remains unchanged after execution of this instruction.  

#### TIMING:  
4 Microseconds  

#### EXAMPLE:  

```
PPP-LLL:   MP1-MP2-MP3-MP4.   E SEQ. NO.   LAB:   VERB   OPERANDS     COMMENTS  
                              *17-160.     SHIFT AND "EOR" ACCUMULATOR  
P16-110:   327-026.            17-170.     SER, S#7; OCT:026.  
```

```
1 1 0 0 0 1 0 1    Initial Accumulator Value
| \___________/
|       |
|     +-+
|     |
+-----|-------+
      |       |
/-----------\ | 
1 0 1 1 1 0 0 0    Initial Accumulator Value after a Shift of 3
0 0 0 1 0 1 1 0    Literal Value
0 0 0 1 0 0 0 0    Accumulator Value after the logical "AND" of OCT:026
```

---

### DPL-1 -- CLASS 3: BOOLEAN -- INCLUSIVE "OR" TO ACCUMULATOR -- IRA  

|      OBJECT      |          SOURCE            |  
|------------------|----------------------------|  
| 360-LLL          | IRA, R#0; Literal.          |  
| 370-YXX          | IRA, R#0; NNN.              |  
| 370-YXX          | IRA, R#0; AAA+NNN.          |  
| 371-YXZ00        | IRA, R#X; PPP.              |  
| 371-YXZ10        | IRA, I#X; PPP.              |  
| 371-YXZ11        | IRA, D#X; PPP.              |  

WHERE:  
- 360 is an immediate address command.  
- LLL is any form of literal notation.  
- 370 is a direct address command.  
- YXX is an 8-bit location address within a level zero page.  
- 37I is an indexed address command.  
- I is any index (1-7).  
- YXZ is a 6-bit base page address.  

WHERE:  
- R#0 is the immediate or direct indicator.  
- AAA is a direct address page within level zero.  
- NNN is a decimal byte displacement.  
- X is any register (1-7).  
- PPP is a decimal page notation.  
- I-Increment register by 001 after execution.  
- D-Decrement register by 001 after execution.  
- R-Register value remains unchanged after execution.  

#### DESCRIPTION:  

Inclusive "or" to the accumulator the value specified by the immediate, direct, or indexed address. The immediate form of this instruction provides the means of specifying machine values or bit configurations as part of the instruction. The direct form of this instruction allows the user to directly address any level zero page. By supplying the base page address as the operand and by specifying the index register containing the address displacement within that page, the user can address any location within the memory. The value of the operand is treated as an unstructured logical quantity, and the value is applied bit by bit to the accumulator. A bit position in the result (accumulator) is set to one if the corresponding bit position in the accumulator or as specified by the operand, either contain a one; otherwise, the result bit is set to zero. (Result is one if either are one). All operand values and results are valid. The condition register value remains unchanged after execution of this instruction.  

#### TIMING:  
4 Microseconds when literal form is used.  
6 Microseconds when literal form is not used.  

#### EXAMPLE:  

```
PPP-LLL:   MP1-MP2-MP3-MP4.   E SEQ. NO.   LAB:   VERB   OPERANDS     COMMENTS  
                              *18-100.     INCLUSIVE "OR" TO ACCUMULATOR  
P16-112:   360-026.            18-110.     IRA, R#0; OCT:026.     IMMEDIATE  
P16-114:   370-007.            18-120.     IRA, R#0; R#7.        DIRECT  
P16-116:   374-030.            18-130.     IRA, R#4; P06.        INDEXED  
P16-120:   374-032.            18-140.     IRA, I#4; P06.        ADDRESSING  
P16-122:   374-033.            18-150.     IRA, D#4; P06.  
```

---

### DPL-1 -- CLASS 3: BOOLEAN -- SHIFT & INCLUSIVE "OR" TO ACCUMULATOR -- SIR  

|      OBJECT      |          SOURCE            |  
|------------------|----------------------------|  
| 361-LLL          | SIR, S#X; Literal.          |  

WHERE:  
- I is the bit shift count.  
- LLL is any literal notation.  

WHERE:  
- X is the bit shift count.  

#### DESCRIPTION:  

This form of the inclusive "or" instruction performs a right circular shift of the bits in the Accumulator, by the number of bits specified in the shift counter, before the inclusive "or" of the literal to the Accumulator is performed. All literal values and results are valid. The condition register value remains unchanged after execution of this instruction.  

#### TIMING:  
4 Microseconds.  

#### EXAMPLE:  

```
PPP-LLL:   MP1-MP2-MP3-MP4.   E SEQ. NO.   LAB:   VERB   OPERANDS     COMMENTS  
                              *18-200.     SHIFT AND INCLUSIVE "OR" TO ACCUMULATOR  
P16-124:   364-026.            19-010.     SIR, S#4; OCT:026.  
```

```
1 1 0 0 0 1 0 1         Initial Accumulator Value  
\_____/ \_____/
    |      |
  +-|------+
  | |
  | +------+
  |        |
/-----\ /-----\

0 1 0 1 1 1 0 0         Accumulator Value after a Shift of 4  
0 0 0 1 0 1 1 0         Literal Value  
0 1 0 1 1 1 1 0         Accumulator Value after the inclusive "OR" of OCT:026  
```

---

## 7. CLASS 3: COMPARE

### DPL-1 -- CLASS 3: COMPARE -- COMPARE ACCUMULATOR -- CPA

|      OBJECT      |          SOURCE            |  
|------------------|----------------------------|  
| 340-LLL          | CPA, R#0; Literal.          |  
| 350-YXX          | CPA, R#0; AAA+NNN.          |  
| 351-YXZ00        | CPA, R#X; PPP.              |  
| 351-YXZ10        | CPA, I#X; PPP.              |  
| 351-YXZ11        | CPA, D#X; PPP.              |  

WHERE:  
- 340 is an immediate address command.  
- LLL is any form of literal notation.  
- 350 is a direct address command.  
- YXX is an 8-bit location address within a level zero page.  
- 351 is an indexed address command.  
- I is any index (1-7).  
- YXZ is a 6-bit base page address.  

WHERE:  
- R#0 is the immediate or direct indicator.  
- AAA is a direct address page within level zero.  
- NNN is a decimal byte displacement.  
- X is any register (1-7).  
- PPP is a decimal page notation.  
- I-Increment register by 001 after execution.  
- D-Decrement register by 001 after execution.  
- R-Register value unchanged after execution.  

#### DESCRIPTION:  

Compare the contents of the Accumulator to the value specified by the immediate, direct or indexed address. The immediate form of this instruction provides the means of specifying machine values or bit configurations as part of the instruction. The direct form of this instruction allows the user to directly address any level zero page. By supplying the base page address as the operand and by specifying the index register containing the address displacement within that page, the user can address any location within the memory. The character in the Accumulator is not altered. The condition register value is changed to reflect the high, low or equal result of the compare instruction. Once set, the condition register remains unchanged until modified by an instruction that reflects a different condition code.  

#### TIMING:  
4 Microseconds when literal form is used.  
6 Microseconds when literal form is not used.  

#### EXAMPLE:  

```
PPP-LLL:   MP1-MP2-MP3-MP4.   E SEQ. NO.   LAB:   VERB   OPERANDS     COMMENTS  
P16-126:   340-026.            19-150.     CPA, R#0; (J.).     IMMEDIATE  
P16-130:   350-007.            19-160.     CPA, R#0; R#7.      DIRECT  
P16-132:   340-136.            19-170.     CPA, R#0; ADL:CPT.  
P16-134:   354-030.            19-180.     CPA, R#4; P06.      INDEXED  
P16-136:   354-032.            19-190.     CPT: CPA, I#4; P06.  ADDRESSING  
P16-140:   354-033.            19-200.     CPA, D#4; P06.  
```

---

### DPL-1 -- CLASS 3: COMPARE -- COMPARE INDEX REGISTER -- CPX

|      OBJECT      |          SOURCE            |  
|------------------|----------------------------|  
| 34I-LLL          | CPX, R#X; Literal.          |  

WHERE:  
- I is any index register (1-7).  
- LLL is any literal notation.  

WHERE:  
- X is any register (1-7).  

#### DESCRIPTION:  

Compare the contents of the index register specified to the byte of immediate data (literal). Comparison is binary, and all codes are valid. The value of the index register is not altered.  

The condition register value is changed to reflect the high, low, or equal result of the compare instruction. Once set, the condition register remains unchanged until modified by an instruction that reflects a different condition code.  

#### TIMING:  
4 Microseconds.  

#### EXAMPLE:  

```
PPP-LLL:   MP1-MP2-MP3-MP4.   E SEQ. NO.   LAB:   VERB   OPERANDS     COMMENTS  
P16-142:   343-006.            20-060.     CRT: CPX, R#3; (3).     IMMEDIATE  
P16-144:   343-146.            20-070.     CPX, R#3; CRT+04.       ADDR. LOC.  
```

---

## 8. GROUP 1: I/O FUNCTIONS

### DPL-2 -- GROUP 1: I/O FUNCTIONS -- GET DATA (READ) -- GET

|      OBJECT         |              SOURCE                |
|---------------------|------------------------------------|
| 017-YXX-0XX-YXX     | GET; NNN, T#N, MMM.                 |
| 017-YXX-2XX-YXX     | GET; NNN, M#N, MMM.                 |
| 017-YXX-012-YXX     | GET; NNN, KBD, MMM.                 |

WHERE:  
- NNN is the decimal size.  
- T#N, M#N, or KBD is the device number of the Mini-Tape, the Maxi-Tape, or the Keyboard, respectively.  
- MMM is the left-most high order decimal address of the receiving field.  

#### DESCRIPTION:  

A Read operation is initiated at the I/O device, and the data is transferred from the device into memory. Page destination is initially set to 0 but may be changed with a SET PAGE Instruction. The Page remains at this setting until a different SET PAGE Instruction is executed. Any data continuing past a Page boundary will be wrapped around to the beginning of the Page.  

#### MAXI-TAPE:
When retrieving records from Maxi-Tape, the same number of bytes as contained in the tape record must be specified by the size operand within the instruction. The size may be up to 256 bytes for Maxi-Tape. Data is placed in memory in ascending order of addresses within the "Into" Page which is currently set, starting with the address specified in the instruction.  

#### MINI-TAPE:
When retrieving records from Mini-Tape, the physical record length **must** be 136 bytes. The standard Mini-Tape record is comprised of an 8-byte label, generated by the Mini-Write software function, followed by 128 bytes of data. Because the label is generated by the software and not by the user, it is not included in the record size operand. Therefore, when reading the standard Mini-Tape record, specify 128 (number of data bytes) as the size. Although a Mini-Tape record may contain a maximum of 128 bytes of data, it may be desirable to read a lesser number of characters into the input buffer. By specifying a lesser number in the size operand, only the number of characters specified will be stored into the I/O area indicated by the user. The remainder of the record will be read and used to check for tape errors and CRC Check but these characters will not be stored into the I/O Buffer. The 8-byte label is automatically read into Page 00 Locations 030 thru 037. The data portion of the record is placed in memory in ascending order of addresses within the "Into" Page which is currently set, starting with the address specified in the instruction. An automatic sequence check is made on the first byte of the label. If the record contains the wrong sequence number (i.e., a record was skipped), the error condition will be set.  

#### KEYBOARD:
When retrieving data from the keyboard, the same number of bytes as contained in the size operand must be entered. The keyboard Supervisor provides for corrections to be made to data entered. By depressing the "CORR" key on the keyboard, the point of entry will be backspaced one location within the current Page. The size operand may specify up to 256 bytes for the keyboard operation. Data is placed in memory in ascending order of addresses within the "Into" Page which is currently set, starting with the address specified in the instruction.  

---

**Device assignment is as follows:**  

| DDD   | DEVICE NAME   | SYMBOLIC CODE | OBJECT CODE |
|-------|---------------|---------------|-------------|
| Standard Pair 1  | Mini-Tape 1 | T#1 | 001 |
|                 | Mini-Tape 2 | T#2 | 002 |
| Optional Pair 2 | Mini-Tape 3 | T#3 | 003 |
|                 | Mini-Tape 4 | T#4 | 004 |
| Optional Pair 3 | Mini-Tape 5 | T#5 | 005 |
|                 | Mini-Tape 6 | T#6 | 006 |
| Optional Pair 4 | Mini-Tape 7 | T#7 | 007 |
|                 | Mini-Tape 8 | T#8 | 010 |
|                 | Keyboard    | KBD | 012 |
|                 | Maxi-Tapes  | M#N | 20X |

#### EXAMPLE:  

```
PPP-LLL: MP1-MP2-MP3-MP4. E SEQ. NO. LAB: VERB OPERANDS COMMENTS
P15-000: 150-000-122-004. 01-100. ENT: DPL-3. SET PAGE
P15-004: 005-006-012-066. 01-110. SET; PAG:F01,T02. SET PAGE
P15-010: 017-200-001-000. 01-120. GET; 128,T#1,000. READ INTO PG2
P15-014: 004-001-017-000. 01-130. SEL; LOW,P15,000. EOC RECORD?
P15-024: 004-004-017-144. 01-140. SEL; HIGH,P15,100. TAPE ERROR?
P15-024: 150-010-105-030. 01-150. ENT: DPL-1. RECORD OK
P15-030: 140-000. 01-160. EXU; 000. RETURN
```

---

### DPL-2 -- GROUP 1: I/O FUNCTIONS -- PUT DATA (WRITE) -- PUT

|      OBJECT       |          SOURCE           |  
|-------------------|---------------------------|  
| 027-YXX-YXX-0XX   | PUT; NNN, MMM, T#N.        |  
| 027-YXX-YXX-2XX   | PUT; NNN, MMM, M#N.        |  
| 027-YXX-YXX-013   | PUT; NNN, MMM, PRT.        |  

WHERE:  
- NNN is the decimal size.  
- MMM is the left-most high order decimal address of the sending field.  
- T#N, M#N, or PRT is the device number of the Mini-Tape, the Maxi-Tape, or the Printer; respectively.  

#### DESCRIPTION:  

A Write operation is initiated at the I/O device, and the data is transferred from memory to the device. The Page source is initially set to 01, but may be changed with a SET PAGE Instruction. The Page remains at this setting until a different SET PAGE Instruction is executed. Data can be written from any location within a Page. Any data continuing past the Page boundaries, based on the size operand, will be wrapped around to the beginning of the Page.  

**MAXI-TAPE:**  
When writing records to Maxi-Tape, the actual number of bytes desired to be written must be specified by the size operand within the Instruction. The size may be up to 256 bytes for Maxi-Tape. Data in memory is fetched in an ascending order of addresses, within the "From" Page which is currently set, starting with the address specified in the Instruction.  

**MINI-TAPE:**  
When writing records to Mini-Tape, the physical record length **will be** 136 bytes. The standard Mini-Tape record is comprised of an 8-byte label, generated by the Mini-Write software function, followed by 128 bytes of data. Because the label is generated by the software and not by the user, it is not included in the record size operand. Therefore, when writing the Standard Mini-Tape record, specify 128 (number of data bytes) as the size. Although a Mini-Tape record may contain a maximum of 128 bytes of data, it may be desirable to write a lesser number of characters from the input buffer. By specifying a lesser number in the size operand, only the number of characters specified will be written from the I/O area indicated by the user. The remainder of the record will contain Octal zeroes. The complete 136 byte record will be used to check for tape write errors.  

The 8-byte label is automatically written from Page 00 locations 030₈ thru 037₈. The record sequence number is automatically generated by the Mini-Write software function. The remainder of the label may be controlled by the user. The data portion of the record is written from memory in ascending order of addresses within the "From" Page which is currently set, starting with the address specified in the Instruction.  

**PRINTER:**  
When printing, the actual number of bytes desired to be printed must be specified by the size operand within the Instruction. The size may be up to 256 characters. Data in memory is fetched in an ascending order of addresses, within the "From" Page which is currently set, starting with the address specified in the Instruction.  

In order to execute a control command for the Print Function as part of the data, the control byte must have the high-order bit present (Ref. I/O Instruction) (i.e. to execute an "Index Function for the typewriter, either execute PCL; 001, PRT, IDX, or Place OCTAL 212 as a character in the print buffer).  

There will be an automatic Carriage Return after each print command.  

**Device assignment is as follows:**  

| DDD      | DEVICE NAME | SYMBOLIC CODE | OBJECT CODE |  
|----------|-------------|---------------|-------------|  
| Standard | Mini-Tape 1 | T#1 | 001 |  
| Pair 1   | Mini-Tape 2 | T#2 | 002 |  
| Optional | Mini-Tape 3 | T#3 | 003 |  
| Pair 2   | Mini-Tape 4 | T#4 | 004 |  
| Optional | Mini-Tape 5 | T#5 | 005 |  
| Pair 3   | Mini-Tape 6 | T#6 | 006 |  
| Optional | Mini-Tape 7 | T#7 | 007 |  
| Pair 4   | Mini-Tape 8 | T#8 | 010 |  
|          | Printer     | PRT | 013 |  
|          | Maxi-Tapes  | M#N | 20X |  

---

#### EXAMPLE:  

```
PPP-LLL: MP1-MP2-MP3-MP4. E SEQ. NO. LAB: VERB OPERANDS COMMENTS
P15-032: 150-000-122-004. 02-020. ENT: DPL-3. -
P15-036: 005-056-006-066. 02-030. SET: PAG:F11,T01. SET PAGE
P15-042: 027-200-000-001. 02-040. PUT: 128,P00,T#1. WRITE
P15-046: 004-001-017-000. 02-050. SEL: LOW,P15,000. EOF (REF. SPOT)
P15-052: 004-004-017-144. 02-060. SEL: HGH,P15,100. TAPE ERROR?
P15-056: 150-010-105-062. 02-070. ENT: DPL-1. RECORD OK
P15-062: 140-000. 02-080. EXU; 000. RETURN
```

---


### GET & PUT

#### LINKAGE:
The **GET** or **PUT** Functions may be used in a DPL-1 context in conjunction with the Pseudo (**ENT:IOS**) or they may be used in a DPL-3 context (**ENT:DPL-3**).

#### RETURN STATUS (DPL-3)

- If the software condition value (P00-377) is `"="`, function good.  
- If the software condition value (P00-377) is `">"`, tape 8-retry error (or Read Sequence error).  
- If the software condition value (P00-377) is `"<"`, file mark read.  

The above conditions may be tested by the software by using the **SEL;** commands.

Location **P00-017₈** contains the Status Byte – Refer to the Instruction Reference Cards for Error Conditions.

#### Return Status (IGS)

The return from **ENT:IOS** will set the status in the hardware condition register and can be tested using DPL-1 corresponding to the above conditions.

---

## 9. GROUP 2: DATA MODIFY

### DPL-2 -- GROUP 2: DATA MODIFY -- MOVE STORAGE-TO-STORAGE -- MOV

|      OBJECT      |           SOURCE           |
|------------------|----------------------------|
| 037-YXX-YXX-YXX  | MOV; NNN, AAA, BBB.        |

WHERE:  
- NNN is the decimal size.  
- AAA is a decimal or symbolic "from" address.  
- BBB is the decimal or symbolic "into" address.  

#### DESCRIPTION:  

The DPL-2 move instruction is used for a storage-to-storage move where the data specified by the A-operand is moved to the address specified by the B-operand address. In storage-to-storage movement the fields may overlap in any desired way. Movement is left to right through each field a byte at a time.  

The "from" and "into" page are initialized as page one. To move "from" a page, or "into" a page other than page one, a SET PAGE instruction must have been previously executed. The page remains at this setting until a different SET PAGE instruction is executed.  

The A-operand and the B-operand may be within the same page or in different pages. Any data continuing past page boundaries will be wrapped around to the beginning of the page.  

The software condition value remains unchanged.  

The hardware condition register is unpredictable after execution of any instruction executed in DPL-3 or IOS Mode.  

#### EXAMPLE:  

```
PPP-LLL:   MP1-MP2-MP3-MP4.   E SEQ. NO.   LAB:   VERB   OPERANDS     COMMENTS  
P15-064:   150-000-122-004.   02-150.     ENT:    DPL-3.             MOVE 10 CHAR.  
P15-070:   005-012-006-066.   02-160.     SET:    PAG:F02,T01.       FROM PAGE 2  
P15-074:   037-012-040-040.   02-170.     MOV:    010,032,032.       TO PAGE 1  
```

---

### DPL-2 -- GROUP 2: DATA MODIFY -- ADD STORAGE-TO-STORAGE -- ADD

|      OBJECT      |          SOURCE            |  
|------------------|----------------------------|  
| 047-YXX-YXX-YXX  | ADD; NNN, AAA, BBB.         |  

WHERE:  
- NNN is the decimal size.  
- AAA is a decimal or symbolic addend 1 address.  
- BBB is a decimal or symbolic addend 2 address.  

Formula:  
(AAA + BBB) = BBB  

#### DESCRIPTION:  

The ADD command adds a decimal value specified by the A-operand to a decimal value specified by the B-operand for the number of bytes indicated by the size operand. The A-operand value and the B-operand value must be the same size. The A-operand value and the B-operand value may contain a sign although it is not included in the size count. Addition is algebraic. The results of the addition displace the previous contents of the B-operand field and any overflow character is lost. The octal value of 001 (−) is the minus sign. Any other value is assumed to be positive. If the A-operand field contains a minus sign, a sign position must be reserved in the result field.  

The A-operand field and the B-operand field may be within the same page or different pages as specified by a Set Page instruction.  

The software condition value is unchanged.  

The hardware condition register is unpredictable after execution of any instruction executed in DPL-3 or IOS Mode.  

#### EXAMPLE:  

PPP-LLL:   MP1-MP2-MP3-MP4.   E SEQ. NO.   LAB:   VERB   OPERANDS     COMMENTS  
P15-100:   047-003-000-100.    03-040.     ADD; 003,000,064.  
           *03-050.  
           *03-060.            600 + (B-OPERAND)  
           *03-070.            200 − (A-OPERAND)  
           *03-080.  
           *03-090.            400 + (B-OPERAND RESULT)  

---

### DPL-2 -- GROUP 2: DATA MODIFY -- SUBTRACT STORAGE-TO-STORAGE -- SUB

|      OBJECT      |          SOURCE            |  
|------------------|----------------------------|  
| 057-YXX-YXX-YXX  | SUB; NNN, AAA, BBB.         |  

WHERE:  
- NNN is the decimal size.  
- AAA is a decimal or symbolic subtrahend address.  
- BBB is a decimal or symbolic minuend address.  
- (BBB-AAA) = BBB  

#### DESCRIPTION:  

The SUB command subtracts a decimal value specified by the A-operand from a decimal value specified by the B-operand. The A-operand value and the B-operand value must be the same size.  

The A-operand value and the B-operand value may contain a sign, although it is not included in the size count. Subtraction is algebraic. The result of the subtraction displaces the previous contents of the B-operand field and any overflow character is lost.  

The octal value of 001(0x01) (-) is the minus sign. Any other value is assumed to be positive. A sign position must be reserved in the result field.  

The A-operand and the B-operand fields may be within the same page or different pages as specified by a set page instruction.  

The software condition value is unchanged.  

The hardware condition register is unpredictable after execution of any instruction executed in DPL-3 or IOS Mode.  

#### EXAMPLE:  

PPP-LLL:  MP1-MP2-MP3-MP4.  E SEQ. NO.  LAB:  VERB  OPERANDS  COMMENTS  
P15-104:  057-003-000-100.  03-150.     SUB;  003,000,064.  
          *03-160.  
          *03-170.                     200 - (B-OPERAND)  
          *03-180.                     100 + (A-OPERAND)  
          *03-190.  
          *03-200.                     300 - (B-OPERAND RESULT)  


---

### DPL-2 -- GROUP 2: DATA MODIFY -- MULTIPLY -- MUL  

|      OBJECT      |          SOURCE            |  
|------------------|----------------------------|  
| 067-YXX-YXX-YXX  | MUL; NNN, AAA, BBB.         |  

WHERE:  
- NNN is the decimal size.  
- AAA is a high order decimal or symbolic multiplier address.  
- BBB is a high order decimal or symbolic multiplicand address.  

#### DESCRIPTION:  

The MUL command multiplies a decimal value specified by the B-operand by a decimal value specified by the A-operand (A × B) for the number of bytes indicated by the size operand. The multiplier may contain a sign, although it is not included in the size count. An unsigned multiplier is assumed to be positive. The extended product area, the size of the multiplicand field plus one, filled with decimal zeros, must be reserved immediately following the multiplicand field. If the multiplicand field is to contain a sign, it must appear immediately following the product area. An unsigned multiplicand field is assumed to be positive. The octal value of 001(0x01) (-) is the minus sign. Any other value is assumed to be positive. If the Multiplier contains a minus sign, a sign position must be reserved in the product field. The sign result in the product field is algebraic.  

The product result of the multiplication displaces the previous contents of the multiplicand field and is right justified with left zeros in the product field.  

Unit Position of the Multiplier Field is:  
AAA+NNN-001.  
Unit Position of the Multiplicand Field is:  
BBB+NNN-001.  
Unit Position of the Product Field is:  
BBB+2×NNN.  

The multiplier and the multiplicand fields may be within the same page or different pages as specified by a set page instruction.  

The software condition value is unchanged.  

The hardware condition register is unpredictable after execution of any instruction executed in DPL-3 or IOS Mode.  

#### EXAMPLE:  

```
PPP-LLL:  MP1-MP2-MP3-MP4.  E SEQ. NO.  LAB:  VERB  OPERANDS  COMMENTS  
P15-110:  005-006-066-066.  04-060.     SET;  PAG:F01,T01.  
P15-114:  067-003-000-100.  04-070.     MUL;  003,000,064.  
```

---

### DPL-2 -- GROUP 2: DATA MODIFY -- DIVIDE -- DIV  

|      OBJECT      |          SOURCE            |  
|------------------|----------------------------|  
| 077-YXX-YXX-YXX  | DIV; NNN, AAA, BBB.         |  

WHERE:  
- NNN is the decimal size.  
- AAA is a decimal or symbolic divisor address.  
- BBB is a decimal or symbolic dividend address.  

#### DESCRIPTION:  

The DIV command divides a decimal value specified by the B-operand by a decimal value specified by the A-operand for the number of bytes indicated by the size operand. The size of the dividend field must be twice the size of the divisor field plus one. The dividend field must be right justified and have at least one leading zero. The maximum value of the dividend is the result of the maximum value of a multiply of the same size, (999....)². The divisor and the dividend fields may contain a sign although it is not included in the size count. The size count is the size of the divisor. An unsigned field is assumed to be positive. Division is algebraic. The octal value 001(0x01) (-) is the minus sign. Any other value is assumed to be positive. If the divisor contains a minus sign, a sign position must be reserved in the quotient field.  

The quotient result of the division displaces the previous contents of the dividend field and is left justified. The size of the quotient is the size of the divisor. The remainder is placed immediately following the quotient.  

Unit Position of the Divisor Field is:  
AAA+NNN-001.  
Unit Position of the Dividend Field is:  
BBB+2×NNN.  
Unit Position of the Quotient Field is:  
BBB+NNN-001.  

The divisor and the dividend fields may be within the same page or different pages as specified by a Set Page instruction.  

The software condition value is unchanged.  

The hardware condition register is unpredictable after execution of any instruction executed in DPL-3 or IOS Mode.  

#### EXAMPLE:  

```
PPP-LLL:  MP1-MP2-MP3-MP4.  E SEQ. NO.  LAB:  VERB  OPERANDS  COMMENTS  
P15-120:  005-006-066-066.  04-130.     SET;  PAG:F01,T01.  
P15-124:  077-003-000-100.  04-140.     DIV;  003,000,064.  
```

---

## 10. GROUP 3: COMPARE

### DPL-2 -- GROUP 3: COMPARE -- COMPARE STORAGE-TO-STORAGE -- COM  

|      OBJECT      |          SOURCE            |  
|------------------|----------------------------|  
| 003-YXX-YXX-YXX  | COM; NNN, AAA, BBB.         |  

WHERE:  
- NNN is the decimal size.  
- AAA is the high order decimal or symbolic address of the compare field.  
- BBB is the high order decimal or symbolic address of the field compared to.  

#### DESCRIPTION:  

Within the current page setting established by a set page instruction, compare the data specified by the A-operand address to the data specified by the B-operand address for the number of bytes indicated by the size operand. The comparison operation proceeds left to right through each field a byte at a time and ends when an inequality is found or end of field is reached. Comparison is binary, with a collating sequence based on ascending binary values. All codes are valid. Memory is not altered as a result of this operation. A field that overflows a page boundary will wrap around to the beginning of the page.  

The software condition register is memory location P00 377(0xFF). This will contain an octal 060(0x30) for >, 057(0x2F) for < or 066(0x36) for =. The "SEL" instructions will test these conditions.  

The result of the compare operation is indicated by the software condition value:  

| Condition | Test |
| --------- | ----- |
| HIGH      | AAA > BBB     |
| LOW       | AAA < BBB   |
| EQUAL     | AAA = BBB    |

#### EXAMPLE:  

```
PPP-LLL:  MP1-MP2-MP3-MP4.  E SEQ. NO.  LAB:  VERB  OPERANDS  COMMENTS  
P15-130:  005-002-076-066.  05-010.     SET;  PAG:F00,T15.  
P15-134:  003-012-150-310.  05-020.     COM;  010,002,200.  
P15-140:  004-002-006-000.  05-030.     SEL;  EQL,P06,000.  
P15-144:  004-000-014-000.  05-040.     SEL;  UNC,P12,000.  
P15-150:                        05-050.  CP2:  A/N: (COMPARE XX).  
```

---

## 11. GROUP 3: SELECT

### DPL-2 -- GROUP 3: SELECT -- SELECT UNCONDITIONAL -- SEL;UNC  

|      OBJECT      |          SOURCE            |  
|------------------|----------------------------|  
| 004-000-YXX-YXX  | SEL; UNC, RRR.              |  
|                  | PNN, LLL.                   |  

WHERE:  
- RRR is a symbolic address.  
- NN is a decimal page.  
- LLL is a decimal address.  

#### DESCRIPTION:  

The Select (Branch) Uncondition command is used in a DPL-3 context to transfer control to a new instruction location regardless of the setting of the software condition value.  

The DPL-2 commands are executed in an interpretive mode and therefore are not limited to section boundaries. In the interpretive mode the SEL command may be used to transfer control to any DPL-2 command or to any DPL-1 command except the DPL-1 branch functions and the jump functions. DPL-1 branch functions and jump functions can only be used in the DPL-1 mode of operation (ENT:DPL-1). The branch address may be represented as a symbolic address or as an absolute address. The software condition value remains unchanged.  

#### EXAMPLE:  

```
PPP-LLL:  MP1-MP2-MP3-MP4.  E SEQ. NO.  LAB:  VERB  OPERANDS  COMMENTS  
P15-162:  004-000-017-000.  05-110.     SEL;  UNC,P15,000.  
P15-166:  004-000-015-166.  05-120.  S01: SEL;  UNC,S01.  
```

---

### DPL-2 -- GROUP 3: SELECT -- SELECT LOW -- SEL;LOW  

|      OBJECT      |          SOURCE            |  
|------------------|----------------------------|  
| 004-001-YXX-YXX  | SEL; LOW, RRR.              |  
|                  | PNN, LLL.                   |  

WHERE:  
- RRR is a symbolic address.  
- NN is a decimal page.  
- LLL is a decimal address.  

#### DESCRIPTION:  

The conditional branch command, select LOW, is used in a DPL-3 context to transfer control to a new instruction location if the software condition register previously set by a DPL-2 compare or a DPL-2 I/O instruction is found to be LOW. If the condition is not satisfied, the next sequential instruction is executed.  

(Refer to "SEL;UNC" for Basic Rules of Select Branching)  

#### EXAMPLE:  

```
PPP-LLL:  MP1-MP2-MP3-MP4.  E SEQ. NO.  LAB:  VERB  OPERANDS  COMMENTS  
P15-172:  004-001-017-000.  05-180.     SEL;  LOW,P15,000.  
P15-176:  004-001-015-176.  05-190.  S02: SEL;  LOW,S02.  
```

---

### DPL-2 -- GROUP 3: SELECT -- SELECT EQUAL -- SEL;EQL  


|      OBJECT      |          SOURCE            |  
|------------------|----------------------------|  
| 004-002-YXX-YXX  | SEL; EQL, RRR.              |  
|                  | PNN, LLL.                   |  

WHERE:  
- RRR is a symbolic address.  
- NN is a decimal page.  
- LLL is a decimal address.  

#### DESCRIPTION:  

The conditional branch command, select EQUAL, is used in a DPL-3 context to transfer control to a new instruction location if the software condition value previously set by a DPL-2 compare or DPL-2 I/O instruction is found to be EQUAL. If the condition is not satisfied, the next sequential instruction is executed.  

(Refer to "SEL;UNC" for Basic Rules of Select Branching)  

#### EXAMPLE:  

```
PPP-LLL:  MP1-MP2-MP3-MP4.  E SEQ. NO.  LAB:  VERB  OPERANDS  COMMENTS  
P15-202:  004-000-017-000.  06-050.     SEL;  EQL,P15,000.  
P15-206:  004-002-015-206.  06-060.  S03: SEL;  EQL,S03.  
```

---

### DPL-2 -- GROUP 3: SELECT -- SELECT HIGH -- SEL;HGH  

|      OBJECT      |          SOURCE            |  
|------------------|----------------------------|  
| 004-004-YXX-YXX  | SEL; HGH, RRR.              |  
|                  | PNN, LLL.                   |  

WHERE:  
- RRR is a symbolic address.  
- NN is a decimal page.  
- LLL is a decimal address.  

#### DESCRIPTION:  

The conditional branch command, select HIGH, is used in a DPL-3 context to transfer control to a new instruction location if the software condition value previously set by a DPL-2 compare or DPL-2 I/O instruction is found to be HIGH. If the condition is not satisfied, the next sequential instruction is executed.  

(Refer to "SEL;UNC" for Basic Rules of Select Branching)  

#### EXAMPLE:  

```
PPP-LLL:  MP1-MP2-MP3-MP4.  E SEQ. NO.  LAB:  VERB  OPERANDS  COMMENTS  
P15-212:  004-004-017-000.  06-120.     SEL;  HGH,P15,000.  
P15-216:  004-004-015-216.  06-130.  S04: SEL;  HGH,S04.  
```

---

### DPL-2 -- GROUP 3: SELECT -- SELECT NOT HIGH -- SEL;NHG  

|      OBJECT      |          SOURCE            |  
|------------------|----------------------------|  
| 004-014-YXX-YXX  | SEL; NHG, RRR.              |  
|                  | PNN, LLL.                   |  

WHERE:  
- RRR is a symbolic address.  
- NN is a decimal page.  
- LLL is a decimal address.  

#### DESCRIPTION:  

The conditional branch command, select NOT HIGH, is used in a DPL-3 context to transfer control to a new instruction location if the software condition value previously set by a DPL-2 compare or DPL-2 I/O instruction is found to be LOW or EQUAL. If the condition is not satisfied, the next sequential instruction is executed.  

(Refer to "SEL;UNC" for Basic Rules of Select Branching)  

#### EXAMPLE:  

```
PPP-LLL:  MP1-MP2-MP3-MP4.  E SEQ. NO.  LAB:  VERB  OPERANDS  COMMENTS  
P15-222:  004-014-017-000.  06-200.     SEL;  NHG,P15,000.  
P15-226:  004-014-015-226.  07-010.  S05: SEL;  NHG,S05.  
```

---

### DPL-2 -- GROUP 3: SELECT -- SELECT NOT EQUAL -- SEL;NEQ  

|      OBJECT      |          SOURCE            |  
|------------------|----------------------------|  
| 004-012-YXX-YXX  | SEL; NEQ, RRR.              |  
|                  | PNN, LLL.                   |  

WHERE:  
- RRR is a symbolic address.  
- NN is a decimal page.  
- LLL is a decimal address.  

#### DESCRIPTION:  

The conditional branch command, select NOT EQUAL, is used in a DPL-3 context to transfer control to a new instruction location if the software condition value previously set by a DPL-2 compare or DPL-2 I/O instruction is found to be LOW or HIGH. If the condition is not satisfied, the next sequential instruction is executed.  

(Refer to "SEL;UNC" for Basic Rules of Select Branching)  

#### EXAMPLE:  

```
PPP-LLL:  MP1-MP2-MP3-MP4.  E SEQ. NO.  LAB:  VERB  OPERANDS  COMMENTS  
P15-232:  004-012-017-000.  07-070.     SEL;  NEQ,P15,000.  
P15-236:  004-012-015-236.  07-080.  S06: SEL;  NEQ,S06.  
```

---

### DPL-2 -- GROUP 3: SELECT -- SELECT NOT LOW -- SEL;NLW  

|      OBJECT      |          SOURCE            |  
|------------------|----------------------------|  
| 004-011-YXX-YXX  | SEL; NLW, RRR.              |  
|                  | PNN, LLL.                   |  

WHERE:  
- RRR is a symbolic address.  
- NN is a decimal page.  
- LLL is a decimal address.  

#### DESCRIPTION:  

The conditional branch command, select NOT LOW, is used in a DPL-3 context to transfer control to a new instruction location if the condition value previously set by a DPL-2 compare or DPL-2 I/O instruction is found to be HIGH or EQUAL. If the condition is not satisfied, the next sequential instruction is executed.  

(Refer to "SEL;UNC" for Basic Rules of Select Branching)  

#### EXAMPLE:  

```
PPP-LLL:  MP1-MP2-MP3-MP4.  E SEQ. NO.  LAB:  VERB  OPERANDS  COMMENTS  
P15-242:  004-011-017-000.  07-140.     SEL;  NLW,P15,000.  
P15-246:  004-011-015-246.  07-150.  S07: SEL;  NLW,S07.  
```

---

## 12. GROUP 4: CONTROL FUNCTIONS

### DPL-2 -- GROUP 4: SET PAGE -- SET PAGE -- SET;PAG

|      OBJECT      |          SOURCE            |  
|------------------|----------------------------|  
| 005-FFF-TTT-III  | SET; PAG: FNN, TNN.         |  

WHERE:  
- FFF is the DPL A-Operand (from) page.  
- TTT is the DPL B-Operand (to) page.  
- III is the DPL Instruction page.  
- FNN is the decimal page setting for the A-Operand data instructions.  
- TNN is the decimal page setting for the B-Operand data instructions.  

#### DESCRIPTION:  

The A-Operand and the B-Operand, in the DPL-2 data functions, specify an address within a page where the data resides. The set page instruction provides a means of controlling the setting of that page as a base address. The page setting for the A-Operand and the B-Operand may be the same page or they may be different pages regardless of the section. Only operands that specify data use the page setting. The page setting is unchanged until another set page instruction is executed reflecting different pages.  

The software condition value is unchanged.  

The hardware condition register is unpredictable after execution on any instruction executed in DPL-3 or IOS Mode.  

#### EXAMPLE:  

```
PPP-LLL:  MP1-MP2-MP3-MP4.  E SEQ. NO.  LAB:  VERB  OPERANDS  COMMENTS  
P15-252:  005-006-076-066.  08-010.  S08: SET;  PAG:F01,T15.   MOVE CHAR.  
P15-256:  037-012-024-112.  08-020.     MOV;  010,020,074.     FROM PAGE 1  
P15-262:  037-004-012-024.  08-030.     MOV;  004,010,020.     TO PAGE 15  
```

---

### DPL-2 -- GROUP 4: I/O CONTROL -- TAPE CONTROL -- TCL

|      OBJECT      |          SOURCE            |  
|------------------|----------------------------|  
| 007-001-0XX-001  | TCL; 001, T#N, BSP.         |  
| 007-001-2XX-001  | TCL; 001, M#N, BSP.         |  
| 007-001-2XX-002  | TCL; 001, M#N, RWD.         |  
| 007-001-2XX-003  | TCL; 001, M#N, RWI.         |  
| 007-001-2XX-004  | TCL; 001, M#N, WFM.         |  

WHERE:  
- N is a decimal tape device number.  
- BSP is a backspace record function,  
- RWI is a maxi-tape rewind with interlock function,  
- RWD is a maxi-tape rewind without interlock function,  
- WFM is a maxi-tape write file mark.  

#### DESCRIPTION:  

These commands control the basic tape operations for the device specified in the instruction. The backspace function (BSP) applies to all tape I/O devices. The backspace function backspaces the device specified by one record.  

The two rewind functions and the write file mark function apply only to maxi-tape devices. The rewind with interlock function (RWI) rewinds the maxi-tape specified and takes the device off-line. After the device has been set off-line, manual intervention is required to return the device to on-line status. The rewind without interlock function (RWD) rewinds the maxi-tape specified, but does not take the device off-line. The write file mark function (WFM) writes a special hardware 3-byte file mark for the maxi-tape specified.  

#### EXAMPLE:  

```
PPP-LLL:  MP1-MP2-MP3-MP4.  E SEQ. NO.  LAB:  VERB  OPERANDS  COMMENTS  
P15-266:  007-001-001-001.  08-100.     TCL;  001,T#1,BSP.     BKSP MINI-1  
P15-272:  007-001-201-001.  08-110.     TCL;  001,M#1,BSP.     BKSP MAXI  
P15-276:  007-001-202-002.  08-120.     TCL;  001,M#2,RWD.     RWD MAXI W/INTL  
P15-302:  007-001-203-003.  08-130.     TCL;  001,M#3,RWI.     RWD MAXI-NO INTL  
P15-306:  007-001-204-004.  08-140.     TCL;  001,M#4,WFM.     WR.FILE MK-MAXI  
```

---

### DPL-2 -- GROUP 4: I/O CONTROL -- TYPEWRITER CONTROL (TYPE I & II) -- PCL

|      OBJECT      |          SOURCE            |  
|------------------|----------------------------|  
| 007-001-013-002  | PCL; 001, PRT, BSC.         |  
| 007-001-013-003  | PCL; 001, PRT, RRS.         |  
| 007-001-013-004  | PCL; 001, PRT, CRT.         |  
| 007-001-013-006  | PCL; 001, PRT, BRS.         |  
| 007-001-013-011  | PCL; 001, PRT, TAB.         |  
| 007-001-013-012  | PCL; 001, PRT, IDX.         |  

#### DESCRIPTION:  

These commands will control the paper and carriage positioning on the IBM 730 and 735 typewriters.  

002 (BSC) Backspace carriage one character position.  

003 (RRS) Red ribbon shift (optional on 735).  

004 (CRT) Carriage return.  

006 (BRS) Black ribbon shift (optional on 735).  

011 (TAB) Position carriage to the first tab stop.  

012 (IDX) Index paper one line.  

#### EXAMPLE:  

```
PPP-LLL:  MP1-MP2-MP3-MP4.  E SEQ. NO.  LAB:  VERB  OPERANDS  COMMENTS  
P15-312:  007-001-013-011.  08-200.  CPT: PCL;  001,PRT,TAB.   TAB ONE FIELD  
P15-316:  027-012-000-013.  09-010.     PUT;  010,000,PRT.     PRINT 10 CHAR.  
P15-322:  007-001-013-004.  09-020.     PCL;  001,PRT,CRT.     CARRIAGE RETURN  
P15-326:  007-001-013-012.  09-030.     PCL;  001,PRT,IDX.     INDEX ONE LINE  
P15-332:  004-000-015-312.  09-040.     SEL;  UNC,CPT.  
```

---

### DPL-2 -- GROUP 4: I/O CONTROL -- LINE PRINTER CONTROL (TYPE II) -- PCL

|      OBJECT      |          SOURCE            |  
|------------------|----------------------------|  
| 007-001-013-060  | PCL; 001, PRT, TOF.         |  
| 007-001-013-070  | PCL; 001, PRT, LFD.         |  

#### DESCRIPTION:  

These commands control the paper positioning on the medium speed line printers.  

060 (TOF) When this command is given the paper will slew to "top of form".  

070 (LFD) This command will feed one line of paper.  

#### EXAMPLE:  

```
PPP-LLL:  MP1-MP2-MP3-MP4.  E SEQ. NO.  LAB:  VERB  OPERANDS  COMMENTS  
P15-336:  027-100-000-013.  09-100.  WTT: PUT;  064,000,PRT.   PRINT 64 CHAR.  
P15-342:  004-004-017-000.  09-110.     SEL;  HGH,P15,000.     PRINT ERROR  
P15-346:  007-001-013-070.  09-120.     PCL;  001,PRT,LFD.     ADVANCE 1 LINE  
P15-352:  004-000-015-336.  09-130.     SEL;  UNC,WTT.  
```

---

## 13. NOTATIONS FOR DPL-3B CONSTANTS

These statements are used to enter data constants into memory, to define and 
reserve areas of memory, and to specify the address of relocatable symbols. 
The statements may be named by symbols so that other program elements can 
refer to the fields they generate. 

The forms OCT, DEC, HEX and A/N may specify one constant or a string of 
constants. 

The form DSA provides a method of reserving specified areas of memory for 
future reference. The contents of the reserved area is not disturbed. 

The form ADC provides a means of storing the address components of relocatable 
symbols. ADC generates a two-byte constant, containing the DPL code of the 
page and the octal code of the location of the symbol. 

CONSTANT NOTATIONS 

OCT: (NNN-NNN-NNN-etc.) 

A byte-string constant in octal notation where the maximum number 
of terms is six. 

HEX: (HH-HH-HH-etc.) 

A byte-string constant in Hex notation where the maximum number 
of terms is eight. 

DEC: (NNN-NNN-NNN-etc. ) 

A byte-string constant in decimal notation where the maximum number 
of terms is six. 

A/N: (XXXXXXX ... etc.) 

A string of keyboard characters where the maximum number of 
characters is 24. 

DSA: (NNN) 

Define Symbol area where NNN is decimal number of bytes required up 
to 256. 

ADC: (AAA.±.NNN) 

Address constant for labels in symbolic notation. This instruction 
generates two-bytes. The first byte contains the DPL page of the 
address specified in increment form. The second byte contains the 
location. 

---

## 14. DPL-1 PSEUDO INSTRUCTIONS

### DPL-1 -- PSEUDO -- ORIGIN LOCATION COUNTER -- ORG  

|      OBJECT      |          SOURCE            |  
|------------------|----------------------------|  
|                  | ORG: PNN, LLL.              |  
|                  | ORG: PNN.                   |  

WHERE:  
- NN is the decimal page of the program origin.  
- LLL is the decimal location within the page.  
- Where LLL is not specified location 000 is assumed.  

#### DESCRIPTION:  

The assembler uses the decimal term specified by the operand to alter the setting of the location counter for the current segment. This value should be on a half-word boundary if instruction statements are to follow. The ORG instruction must appear following each SEG (segment) or OVL (overlay) statement, and may appear elsewhere within the segment. If the ORG instruction is omitted following SEG or OVL, the assembler sets the initial instruction address to zero. The ORG operand specifies a page and location as either an absolute address, or as an implied address of location 000 within the page specified, if the location is not included in the operand. Each ORG statement is considered one label of the 128 possible labels.  

#### EXAMPLE:  

```
PPP-LLL:  MP1-MP2-MP3-MP4.  E SEQ. NO.  LAB:  VERB  OPERANDS  COMMENTS  

                           10-P10.  OVL: PID.               OVERLAY ID  
                           10-P20.  ORG: P10.              ORIGIN P10,000  
P12-000:                   10-P30.  A/N: (012).  
                           10-P40.  ORG: P10, 128.           ORIGIN P10,128  
P12-200:                   10-P50.  A/N: (XXX).  
```

---

### DPL-1 -- PSEUDO -- IDENTIFY SEGMENT -- SEG  

|      OBJECT      |          SOURCE            |  
|------------------|----------------------------|  
|                  | SEG: PID.                   |  

WHERE:  
- PID is any 3 character segment identification.  

#### DESCRIPTION:  

A segment is a block of program coding that can be relocated independently of other coding if linkage addresses are changed where necessary. The concept of program segmenting is a consideration at coding time, assembly time, and at object generation time. By using the form of the Branch functions specifying the absolute address to which control is to be passed at execution time, external segments may be referenced. In assembled multi-segment programs, segments may symbolically address locations in other segments. A program is composed of at least one segment, and the SEG or OVL pseudo must be the first instruction encountered during assembly which is immediately followed by an ORG pseudo. Any three characters may be used for segment identification. The SEG identification is contained in all subsequent source instructions up to the end of the segment. The SEG identification assigned by the SEG pseudo is used in conjunction with the USE pseudo to retrieve external segments at object generation time.  

#### EXAMPLE:  

```
PPP-LLL:  MP1-MP2-MP3-MP4.  E SEQ. NO.  LAB:  VERB  OPERANDS  COMMENTS  

                           10-110.  SEG: PID.                SEGMENT ID  
                           10-120.  ORG: P08, 000.            START LOCATION  
P10-000: 200-000.          10-130.  LDA, R#0; OCT:000.  
```

---

### DPL-1 -- PSEUDO -- ENTER CONTROL FUNCTION -- ENT

|      OBJECT      |          SOURCE            |  
|------------------|----------------------------|  
| 150-YXX-10X-YXX  | ENT: DPL-1.                 |  
| 150-000-122-004  | ENT: DPL-3.                 |  
| 150-000-123-004  | ENT: IOS.                   |  

WHERE:  
- 150-YXX is the section.  
- DPL-1 is a machine executable mode.  
- DPL-3 is an interpretive mode.  
- IOS is the I/O supervisor.  

#### DESCRIPTION:  

**ENT:**  

The ENT pseudo instructions change the operating context for the program instructions. There are three forms of the ENT pseudo and each generates Branch linkage code to the appropriate control point.  

ENT:DPL-1 switches the instruction environment from interpretive DPL-3 mode into direct execution DPL-1 mode. DPL-1 mode is the normal hardware context and executes instructions at machine speed. Only DPL-1 and Pseudo instructions may be executed in DPL-1 mode. This pseudo will be an SMS and a BRU to the next instruction in sequence.  

ENT:DPL-3 switches the instruction environment from direct DPL-1 mode into interpretive DPL-3 mode. In DPL-3 mode any DPL-1 instruction except Class 0, Class 1 and any DPL-2 statement may be executed under control of a resident software monitor. Exit from DPL-3 mode is accomplished only with an ENT:DPL-1 pseudo instruction.  

ENT:IOS switches control temporarily from a DPL-1 context into the Input/Output Supervisor for the execution of one I/O function. The DPL-2 I/O commands (GET, PUT, SET, TCL, PCL) are used to specify the I/O operation. Following execution, control is automatically returned to DPL-1 mode and the succeeding instructions.  

**IOS:**  

The Input Output Supervisor is a resident monitor program used to provide complete I/O functions for DPL-1 programs. The ENT:IOS pseudo instruction is used to turn program control over to the Supervisor. After one complete I/O function has been performed, program control is automatically returned to the using DPL-1 program. The I/O function to be performed is specified using a GET, PUT, PCL or TCL command from the DPL-2 instruction set. A SET;PAG command may precede the I/O function command where required.  

The I/O buffer page for the Supervisor is set initially to page 01. The SET;PAG command changes the page context for the GET and PUT commands where desired.  

All index registers in section 0 are used by the IOS during its operation and their contents lost. Any valuable data contained in these index registers should be saved by the user program before calling the Supervisor and restored by the user program after return from the IOS.  

The Supervisor uses the software status byte as a status indicator upon its return to the user program. This condition may be tested by using the DPL-2 "SEL" command. Equal condition means that the I/O function has been successfully completed. High condition indicates that an error has occurred. Low condition means that a file mark or end of file record has been detected during a tape read operation. When a high condition is encountered the user should branch to an error routine. The software status byte (P00-017) can help diagnose an error that occurred during a mini-tape read or write. If the status byte contains the value eight, a retry failure is indicated.  

Refer to the Cogar System 4 Instruction Reference Card for explanation of the status byte.  

#### EXAMPLE:  

```
PPP-LLL:  MP1-MP2-MP3-MP4.  E SEQ. NO.  LAB:  VERB  OPERANDS  COMMENTS  

P10-002:  201-012.          10-190.  LDX, R#1; HEX:0A.  
P10-004:  150-000-122-004.  10-200.  ENT: DPL-3.  
P10-010:  017-200-001-200.  11-010.  GET; 128,T#1,128.  
P10-014:  037-012-200-226.  11-020.  MOV; 010,128,150.  
P10-020:  047-012-226-310.  11-030.  ADD; 010,150,200.  
P10-024:  150-010-100-030.  11-040.  ENT: DPL-1.  
                           *11-050.  
P10-030:  150-000-123-004.  11-060.  ENT: IOS.  
P10-034:  005-006-076-042.  11-070.  SET; PAG:F01,T15.  (OPTIONAL INST)  
P10-040:  017-200-001-000.  11-080.  GET; 128,T#1,000. AUTOMATICALLY.  
P10-044:  201-030.          11-090.  LDX, R#1, DEC:024. ENTERS DPL-1  
```

---

### DPL-1 -- PSEUDO -- EQUATE SYMBOL -- EQU

|      OBJECT      |          SOURCE            |  
|------------------|----------------------------|  
|                  | LAB: EQU: PNN, LLL.         |  
|                  | LAB: EQU: RRR.              |  

WHERE:  
- LAB is a symbolic label.  
- NN is the decimal page.  
- LLL is the decimal location within the page.  
- RRR is a symbolic reference.  

#### DESCRIPTION:  

The EQU pseudo instruction defines a symbol by assigning it to either an absolute location or another symbol. The EQU instruction is the means of equating symbols to registers, relocatable expressions, and other arbitrary values.  

The EQU operand may be represented as an absolute expression, or as a symbolic label present in the context of the program unit.  

#### EXAMPLE:  

```
PPP-LLL:  MP1-MP2-MP3-MP4.  E SEQ. NO.  LAB:  VERB  OPERANDS  COMMENTS  

                    11-160.  SEG: ABC.                  EQUATE E01 TO  
                    11-170.  ORG: P10.                  AN EXTERNAL  
                    11-180.  E01: EQU: P12, 000.             SEGMENT  
                    11-190.  E02: EQU: XYZ.                E02-INTERNAL  
                   *11-200.  
P12-000:  231-052.  12-010.  XYZ: STA, I#1; P10.  
P12-022:  104-000.  12-020.  BRU; E01.  
```

---

### DPL-1 -- PSEUDO -- OVERLAY -- OVL  

|      OBJECT      |          SOURCE            |  
|------------------|----------------------------|  
|                  | OVL: PID.                   |  

WHERE:  
- PID is any 3 non-blank character overlay identification.  

#### DESCRIPTION:  

The OVL pseudo names a section of program coding in the same way that SEG pseudo does, and restrictions are identical. Program overlays must be considered at coding time.  

In contrast to the SEG segment, which generates object coding into the main body of the program, the OVL segment generates overlay records outside the main body.  

At object generation time, each OVL segment is inserted into the object string tape, in the order that they occur, following the records used in loading the full memory. The overlay records are retrieved into memory, under user program control, using the normal I/O procedures.  

#### EXAMPLE:  

```
PPP-LLL:  MP1-MP2-MP3-MP4.  E SEQ. NO.  LAB:  VERB  OPERANDS  COMMENTS  

  12-080.  SEG: PID.               MAIN BODY OF  
  12-090.  ORG: P10, 000.            PROGRAM  
          *12-100.  
          *12-110.  
  12-120.  OVL: XYZ.               1ST OVERLAY  
  12-130.  ORG: P02, 000.           RECORD  
          *12-140.  
  12-150.  END: *+0.              (MUST HAVE END)  
```

---

### DPL-1 -- PSEUDO -- USE EXTERNAL SOURCE SEGMENT -- USE  

|      OBJECT      |          SOURCE            |  
|------------------|----------------------------|  
|                  | USE: PID.                   |  

WHERE:  
- PID is an external OVL or SEG identifier.  

#### DESCRIPTION:  

The USE pseudo instruction identifies an independently defined segment or overlay that is to form part of the current program. The retrieval of these segments, at object generation time, can be effected only if the assembler is able to identify the 3 position name in the USE operand with a segment name established on the source primer tape. At object generation time, when a USE pseudo is encountered, the object string generation of the current source primer is interrupted. The user is then instructed to continue processing, using the source primer tape containing the identification specified by the USE operand. The first set of identifiers that satisfy the USE operand will continue the object generation process until an END pseudo instruction is reached. If, within the segment specified by the USE pseudo, another use pseudo is encountered (nested USE) the same interrupt procedure takes place. When a segment is completed, the trail back must be initiated by using the most currently interrupted source primer.  

```
+-----------------+      +-------------------------------+
| LIBRARY SOURCE- |      |       NEWLY ASSEMBLED         |
| PRIMER CONTAINS |      |       SOURCE-PRIMER           |
| SEGMENT "ABC".  |      |       CONTAINING A            |
|                 |      |       "USE" PSEUDO.           |
...................      .................................
        |                            |
        |                 USE:ABC    V
        V                - - - - - - - - - - - - - - - - -
- - - - - - - - - -      | INTERRUPT O-STRING GENERATION,|
|  SEG:ABC        |      | AND INITIATE A SEARCH FOR     |
|                 |      | THE SEGMENT "ABC" ON          |
|  END:...        |      | ANOTHER LIBRARY SOURCE-PRIMER,|
- - - - - - - - - -      | CONTAINING THE SEGMENT "ABC". |
        |                - - - - - - - - - - - - - - - - -
        |                             |
        V                             V
...................      .................................
|                 |      |                               |
+-----------------+      +-------------------------------+

```

---

### DPL-1 -- PSEUDO -- END SEGMENT -- END  

|      OBJECT      |          SOURCE            |  
|------------------|----------------------------|  
| 10X-YXX          | END: PNN, LLL.              |  
| 10X-YXX          | END: RRR.                   |  

WHERE:  
- 10X is a Branch command.  
- X is the page within Section I.  
- YXX is the location.  
- NN is the decimal page address.  
- LLL is the decimal location.  
- RRR is a symbolic reference.  

#### DESCRIPTION:  

The END pseudo instruction is used to define the end of a program segment or overlay and to identify the starting address for program execution. This starting address may be different than the origin address and is specified as an absolute or symbolic address within Section I. For multiple segment programs, the starting address from the last encountered END instruction is used.  

The END pseudo generates a Branch Unconditional instruction to the address specified by the operand.  

At object generation time, this generated Branch instruction is inserted into the background in the corresponding location of Page 2, locations 2 and 3, and is used as the entry point within the section assigned (P02-000) at execution time. If the format (END:*+0.) is used, this branch address will not be inserted into the background. This format is commonly used to terminate an overlay.  

#### EXAMPLE:  

```
PPP-LLL:  MP1-MP2-MP3-MP4.  E SEQ. NO.  LAB:  VERB  OPERANDS  COMMENTS  

                            13-140.  SEG: XYZ.  
                            13-150.  ORG: P08, 000.  
                           *13-160.  
                           *13-170.  
P10-000: 174-011.  13-180.  BGN: IOC, C#4; 011.  DISPLAY  
                           *13-190.  
                           *13-200.  
                            14-010.  END: BGN.              LINK TO BEGIN  
```

---

### DPL-1 -- PSEUDO -- EJECT -- EJT  

|      OBJECT      |          SOURCE            |  
|------------------|----------------------------|  
|                  | EJT: 000.                   |  

#### DESCRIPTION:  

The EJT pseudo instruction causes the printer to go to Top of Form before printing out the next instruction, during a Source Listing operation. It thus allows the programmer to set up the listings in easily read formats. The Sequence Number for this instruction, but not the instruction itself, is printed on the Source Listing.  

---

## 15. DPL-1 BRANCH AND I/O

### DPL-1 -- CLASS 1: BRANCH AND I/O -- MINI-TAPE   -- IOC

|      OBJECT      |          SOURCE            |  
|------------------|----------------------------|  
| 170 FFF          |                            |  
| 171 FFF          | IOC, C#N; FFF.             |  
| 172 FFF          |                            |  

WHERE:  
- FFF is Function Code  
- N=0 Current tape channel selected.  
- N=1 Tape cartridge #1 selected.  
- N=2 Tape cartridge #2 selected.  

TIMING: 4 - 6 Microseconds  

#### FFF (Function Codes) DESCRIPTION  

000 FORWARD, SLOW, ERASE  
Start Tape Forward with Erase. This command sets the run direction and the erase control for the selected tape channel. This command initiates a Tape Write Routine. Since the Erase is active, the tape will be erased until subsequent write data commands. After this command is given, a time delay of approximately 30 M sec should be given to allow the tape to reach a stable speed of 10 in/sec. before the writing of data is begun.  

001 FORWARD, SLOW  
This instruction starts the selected tape forward with Erase condition off. This instruction generally initiates a tape read sequence.  

002 FORWARD, FAST  
This command sets the run, forward, and high speed control in the tape electronics starting the tape forward at 40 inches/sec.  

003 REVERSE, SLOW  
This command sets the run control, resets the high speed and forward control, starting the tape reverse normal speed. When the Forward Control is in reset state, the erase function is inhibited preventing the erasing of data on any tape reverse condition. When in reverse if the clip comes home, (tape rewound) the run control is reset stopping tape motion.  

004 REVERSE, FAST  
This command is identical to the reverse normal command except the tape is driven at high speed 40 inches/sec.  

005 STOP  
This command resets the run control stopping tape. Again, the channel may or may not be specified.  

007 TAPE TRANSFER BYTE AND  
207 TAPE TRANSFER BYTE, SKIP  
This command controls the transfer of characters to and from the tape interface. The transfer is controlled by a Busy or Not Ready condition within the tape controls and can be executed in two modes, Stall on Busy, and Skip on Busy. When executed in the Stall if Busy mode, the program stalls at the transfer byte instruction until a tape sprocket is generated indicating that a byte has been written or read. In the Skip on Busy mode, the program automatically skips the next sequential instruction if a character has not been received.*  

When a program is in a Read or Write subroutine, a Transfer Byte instruction must be given every 512 us. I.E. - the loop from transfer byte to transfer byte must not exceed 512 us.  

010 WRITE MODE  
This command sets the write operation and begins the timing sequence that controls the writing frequency, loads and shifts the tape buffer and generates the sprockets to drop the stall condition.  

This command will follow the start forward normal with erase command, the time delay and any set-up commands. Included in the set-up instruction should be a loading of the ACC with the first to be written. Immediately following the write set should be a transfer byte command. The write set must be given **only once** in a write sequence.  

011 READ MODE  
This command activates the tape read circuitry within the tape systems. It has to be executed only once in a normal tape read sequence. The setting of the Read condition/resets the Write condition.  

012 REWIND  
This command will set a rewind F/F for the specified tape or the current tape which will be reset only by the clip-in signal. This permits overlapped rewinds or rewinding one tape while performing an operation on the other tape.  

*NOTE: The Accumulator value is destroyed after execution of a "Skip/Busy" Instruction.  

016 SELECT DECK 1 IF N=1, DECK 2 IF N=2 & LOAD ITS STATUS (PAIR 1)  
026 SELECT DECK 3 IF N=1, DECK 4 IF N=2 & LOAD ITS STATUS (PAIR 2)  
036 SELECT DECK 5 IF N=1, DECK 6 IF N=2 & LOAD ITS STATUS (PAIR 3)  
046 SELECT DECK 7 IF N=1, DECK 8 IF N=2 & LOAD ITS STATUS (PAIR 4)  

These commands will Select a Tape Deck and load its status in the Accumulator. If N=0, the status of the current deck will be loaded.  

```
 7  6  5  4  3  2  1  0
 |  |  |  |  |  |  |  |
 |  |  |  |  |  |  |  +-- Keyboard Error
 |  |  |  |  |  |  +----- Tape Error
 |  |  |  |  |  +-------- I/O STATUS
 |  |  |  |  +----------- Tape Runaway
 |  |  |  +-------------- Tape - Cartridge Out
 |  |  +----------------- Clip Out
 |  +-------------------- EOT
 +----------------------- Not Used
```

This instruction will end a read sequence. After the status has been loaded to the Accumulator, the Read, Runaway and Tape Error will be reset. It is important that this command be given before stopping tape and before the end of the block. Either of these conditions gives an energy dropout and a resulting tape error.  

This instruction may ask for either channel of one of the 4 PAIRS or the current channel. A specific channel command is useful in a rewind test to determine end of rewind. It is not possible to check the error status on both decks of a selected pair since the first command will reset the error. A Tape error occurs during the reading of a block of data if a significant crossing falls outside of the data window or any energy dropout of 2 ms occurs during a write check. A runaway condition occurs if the read F/F is set and no energy is detected for approximately 5 sec at normal speed or 50 M sec at high speed. These conditions set the tape error F/F and the runaway F/F respectively.  

When either F/F is set the tape logic forces the generation of sprockets from the internal timing rather than data, to allow the program loop to finish.  

The runaway condition will also reset the run F/F, stopping tape.  

---

### DPL-1 -- CLASS 1: BRANCH AND I/O -- KEYBOARD -- IOC   

|      OBJECT      |          SOURCE            |  
|------------------|----------------------------|  
| 173-FFF          | IOC, C#3; FFF.              |  

TIMING: 4 - 6 Microseconds.  
WHERE: FFF is the Function Code  

#### FFF (Function Codes) Description  

007 KEYBOARD TRANSFER BYTE AND  
207 KEYBOARD TRANSFER BYTE, SKIP  
This command controls the transfer of characters from the keyboard interface to the accumulator. The transfer is controlled by a Busy or Not Ready condition within the keyboard controls and can be executed in two modes, Stall on Busy, and Skip on Busy. When executed in the Stall if Busy mode, the program stalls at the transfer byte instruction until a keyboard sprocket is generated indicating that a byte is ready to be transferred. In the Skip on Busy mode, the program automatically skips the next sequential instruction if a character has not been received.  

NOTE: The Accumulator value is destroyed after execution of a "Skip if Busy" Instruction.  

013 BEEP  
This command will produce an electronic beep. This may be used for feedback to the operator after a keystroke, an error tone, etc.  

016 LOAD STATUS  
This command will load a status word to the ACC. The 0 bit signals a keyboard error. The other bits reflect the I/O and current tape status.  

---

### DPL-1 -- CLASS 1: BRANCH AND I/O -- DISPLAY CONTROL -- IOC

|      OBJECT      |          SOURCE            |  
|------------------|----------------------------|  
| 174-FFF          | IOC, C#4; FFF.              |  

WHERE: FFF is the function code.  

#### DESCRIPTION:  

The function code has the following structure:  

FFF = SS-LIU-DLM  

WHERE:  
- S is the section bits of the page to be displayed.  
- L is the level bits of the page number to be displayed.  
- I is the interleave bit in 8 line display mode and the half page (zone) bit in 4 line display mode. See note for definition of interleave.  
- U is the underscore bit. When U = 1, any display character with a bit 6 will be underscored.  
- D is the disable CRT bit.  
- M is the 4/8 line mode select bit. If M = 0, the 8 line display mode is selected.  

TIMING: 4 Microseconds.  

#### EXAMPLE:  

174-000 8 line normal mode - page 0  
174-020 8 line interlace mode - page 0  
174-001 4 line odd zone (zone 1) - (P00-200 thru P00-377).  
174-021 4 line even zone (zone 0) - (P00-000 thru P00-177).  

**Note on Interleave:** (8-line option only)  

In the normal display mode (not interleaved), a page will be displayed in a continuous fashion, location 000 through 377, octal notation.  

Line 1 Loc. 000 Octal through Loc. 037 Octal  
Line 2 Loc. 040 Octal through Loc. 077 Octal  
Line 3 Loc. 100 Octal through Loc. 137 Octal  
Line 4 Loc. 140 Octal through Loc. 177 Octal  
Line 5 Loc. 200 Octal through Loc. 237 Octal  
Line 6 Loc. 240 Octal through Loc. 277 Octal  
Line 7 Loc. 300 Octal through Loc. 337 Octal  
Line 8 Loc. 340 Octal through Loc. 377 Octal  

---

The interleave mode will display this information in the following sequence:  

Line 1 Loc. 000 Octal through Loc. 037 Octal  
Line 5 Loc. 200 Octal through Loc. 237 Octal  
Line 2 Loc. 040 Octal through Loc. 077 Octal  
Line 6 Loc. 240 Octal through Loc. 277 Octal  
Line 3 Loc. 100 Octal through Loc. 137 Octal  
Line 7 Loc. 300 Octal through Loc. 337 Octal  
Line 4 Loc. 140 Octal through Loc. 177 Octal  
Line 8 Loc. 340 Octal through Loc. 377 Octal  

#### EXAMPLE: Display Page 09 (Octal Page 11)  

IOC, C#4;123. 4 lines from loc. 000 to 177, No Underscore.  
IOC, C#4;113. 4 lines from loc. 200 to 377, With Underscore.  
IOC, C#4;102. 8 lines from loc. 000 to 377.  
IOC, C#4;112. 8 lines from loc. 000 to 377, With Underscore.  
IOC, C#4;122. 8 lines Interleaved  
IOC, C#4;132. 8 lines With Underscore and Interleaved.  

---

# APPENDIX

## DPL-1 Instructions

## Class 0 – Jump Instructions

**Mnemonic**  
TLJ+  
TLJ−

**Timing**  
4 µs Jump, 3\* µs NO Jump

**Description**  
Test Literal and Jump  
Compare the instruction Literal to the Accumulator.  
On comparison equal jump +NNNN. On comparison not equal execute next instruction.

**Binary Format**

```
7 6 5 4 3 2 1 0 7 6 5 4 3 2 1 0
0 0 0 N N N N 0 L L L L L L L L (TLJ+)
0 0 0 N N N N 1 L L L L L L L L (TLJ−)
```


**Mnemonic**  
TMJ+  
TMJ−

**Timing**  
4 µs Jump, 3\* µs NO Jump

**Description**  
Test Mask and Jump  
Compare the instruction Mask to the Accumulator.  
On comparison equal jump +NNNN. On comparison not equal execute next instruction.  
Mask logical ones are only bits compared.

**Binary Format**

```
     7 6 5 4 3 2 1 0 7 6 5 4 3 2 1 0
TMJ+ 0 0 1 N N N N 0 M M M M M M M M
TMJ- 0 0 1 N N N N 1 M M M M M M M M
```

**Notes**  
1. Condition register set for +, −, = compare.  
2. Jump past section boundary allowed.  
3. N = Jump Count  
   L = Literal  
   M = Mask


**Mnemonic**  
TLX  
TMX

**Timing**  
4 µs

**Description**  
Test literal and exit, test mask and exit.  
Compare the instruction literal/instruction mask to the accumulator.  
On comparison equal, exit. On comparison not equal, execute next instruction.  
Mask logical ones are only bits compared.

**Binary Format**

```
    7 6 5 4 3 2 1 0 7 6 5 4 3 2 1 0
TLX 0 0 0 0 0 0 0 0 L L L L L L L L
TMX 0 0 1 0 0 0 0 0 M M M M M M M M
```

**Notes**  
1. Condition register set for +, −, = compare.  
2. L = literal  
   M = mask



## Class 1 – Branch and I/O Instructions

**Mnemonic**  
BRU  
BRE  
BRH  
BRL  

**Timing**  
4 µs Branch, 3\* µs NO Branch  

**Description**  
Branch Unconditional  
Branch on Equal  
Branch on High  
Branch on Low  

On condition, branch directly to the 11-bit address carried in the instruction.  
Condition register previously set by a Jump or Compare instruction.  
The 11 bits of the direct address replace the least significant 11 bits of the current IAW.  

**Binary Format**  

```
    7 6 5 4 3 2 1 0 7 6 5 4 3 2 1 0  
BRU 0 1 0 0 0 A A A A A A A A A A 0  
BRE 0 1 0 0 0 A A A A A A A A A A 1  
BRH 0 1 0 0 1 A A A A A A A A A A 0  
BRL 0 1 0 0 1 A A A A A A A A A A 1  
```

**Notes**  
1. The least significant bit of the direct address is assumed to be zero and that bit in the instruction is used as part of the operation code.
2. A = Address


**Mnemonic**  
SBU  
SBE  
SBH  
SBL  

**Timing**  
4 µs Branch, 3\* µs NO Branch  

**Description**  
Stack and Branch Unconditional  
Stack and Branch on Equal  
Stack and Branch on High  
Stack and Branch on Low  

On condition, increment the stack pointer, store the 11-bit direct address carried by the instruction into the least significant 11 bits of the new IAS member and branch to the resulting IAW.  
The condition register is set by a previous Jump or Compare instruction.  

**Binary Format**  

```
    7 6 5 4 3 2 1 0 7 6 5 4 3 2 1 0  
SBU 0 1 0 1 0 A A A A A A A A A A 0  
SBE 0 1 0 1 0 A A A A A A A A A A 1  
SBH 0 1 0 1 1 A A A A A A A A A A 0  
SBL 0 1 0 1 1 A A A A A A A A A A 1  
```

**Notes**  
1. The least significant bit of the direct address is assumed to be zero and that bit in the instruction is used as part of the operation code.  
2. A = Address


**Mnemonic**  
EXU  
EXB  

**Timing**  
4 µs  

**Description**  
Exit Unconditional  
Exit and Branch  

The exit instructions decrement the Stack Pointer and return program control to the previous IAS position.  
For EXU the IAW in that position is used.  
For EXB the 11 least significant bits of the IAW in that position are replaced by the 11-bit direct address carried in the instruction.  

**Binary Format**  

```
    7 6 5 4 3 2 1 0 7 6 5 4 3 2 1 0  
EXU 0 1 1 0 0 0 0 0 0 0 0 0 0 0 0 0  
EXB 0 1 1 1 0 A A A A A A A A A A 0  
```

**Notes**  
1. The least significant bit of the direct address is assumed to be zero and that bit in the instruction is used as part of the operation code.  
2. A = Address



**Mnemonic**  
SMS  

**Timing**  
4 µs  

**Description**  
Set memory section  
Provides a means of transferring control from the current section to an outside section.  

**Binary Format**  

7 6 5 4 3 2 1 0 7 6 5 4 3 2 1 0  
SMS 0 1 1 0 1 0 0 0 0 0 S S S 0 0 0  

**Notes**  
1. S is the section bits defining the section that control will be transferred to.



**Mnemonic**  
SMC  
SSC  

**Timing**  
4 µs  

**Description**  
Set memory control.  
Set memory section and control.  

When the U bit is set to 0, the address of the index registers is memory location 1–7 and direct addressing is only available in page 0 of section 0.  
When the U bit is set to 1, the effective index register address is location 1–7 of the section where the indexed instruction is being executed. Likewise, the effective direct address is page 0 of the section where the direct address instruction is being executed.  

When the V bit is set to 1, any branch, stack & branch, or exit & branch instructions given with page 0 specified in the branch address will cause the branch to occur with the current section and page of the program. If any page other than 0 is specified in the branch address, the V bit control is inactive and a normal branch will occur.  

Set memory section and control is a combination of set memory section and set memory control instructions.  

**Binary Format**  

```
    7 6 5 4 3 2 1 0 7 6 5 4 3 2 1 0  
SMC 0 1 1 0 1 0 0 0 1 U V 0 0 0 0 0 0  
SSC 0 1 1 0 1 0 1 0 U V S S S 0 0 0  
```

**Notes**  
- U = U bit  
- V = V bit  
- S = Section bits


**Mnemonic**  
SAC  

**Timing**  
4 µs  

**Description**  
Set arithmetic condition.  
Arithmetical conditions of the processor will be forced to a +, −, = condition dependent upon the state of Acc. bits 4 & 5.  
00 sets −, 01 sets +, 10 sets =, and 11 is invalid.  

**Binary Format**  

```
               7 6 5 4 3 2 1 0 7 6 5 4 3 2 1 0  
SAC            0 1 1 0 1 0 1 1 0 0 0 0 0 0 0 0  

Acc. (force +) 0 0 0 1 0 0 0 0  
Acc. (force −) 0 0 0 0 0 0 0 0  
Acc. (force =) 0 0 1 0 0 0 0 0
```



**Mnemonic**  
LSW  

**Timing**  
4 µs  

**Description**  
Load sense switches.  
The state of 8 toggle switches (located in the switch well under the CRT screen) to the accumulator.  

**Binary Format**  

```
    7 6 5 4 3 2 1 0 7 6 5 4 3 2 1 0  
LSW 0 1 1 0 1 1 0 0 0 0 0 0 0 0 0 0
```




**Mnemonic**  
DPI  
EPI  
CPI  

**Timing**  
4 µs  

**Description**  
Disable processor interrupt.  
Enable processor interrupt.  
Clear processor interrupt.  

The automatic stack and branch that results from an interrupt is program enabled or disabled.  
The interrupt overflow indicator can be reset by the clear instruction.  

**Binary Format**  

```
    7 6 5 4 3 2 1 0 7 6 5 4 3 2 1 0  
DPI 0 1 1 0 1 1 1 0 0 0 0 0 0 0 0 0  
EPI 0 1 1 0 1 1 1 0 0 0 0 0 0 0 0 1  
CPI 0 1 1 0 1 1 1 0 0 0 0 0 0 0 1 0
```

**Mnemonic**  
IOC  

**Timing**  
3\* µs  

**Description**  
Input/Output Control  
This instruction is used for all input and output operations.  
The IWL is used to designate the I/O sub-class and to pick the I/O device.  
The IWR designates the function to be performed.  

**Binary Format**  

```
    7 6 5 4 3 2 1 0 7 6 5 4 3 2 1 0  
IOC 0 1 1 1 1 n n n y y x x x x x x  
```

**Notes**  
1. n = Device designation  
   y, x = Command micro-code  
2. Appendix C gives detailed listing of all IOC commands.



**Mnemonic**  
LPS

**Timing**  
3\* µs  

**Description**  
Load Processor Status. Execution of this command transfers a hardware status word to the accumulators.  

**Binary Format**  

```
    7 6 5 4 3 2 1 0 7 6 5 4 3 2 1 0  
LPS 0 1 1 0 1 1 0 1 0 0 0 0 0 0 0 0  
```

**ACC BIT**  

| Bit | Function                          |
|-----|-----------------------------------|
| 0   | Stack Pointer Address Bit 2¹      |
| 1   | Stack Pointer Address Bit 2²      |
| 2   | Stack Pointer Address Bit 2³      |
| 3   | Stack Pointer Address Bit 2⁴      |
| 4   | Plus Condition                    |
| 5   | Equal Condition                   |
| 6   | Interrupt Overflow                |
| 7   | Program Interrupt Switch          |


\* If the instruction is located at the low order address of any page, 1 µSec is added to the instruction time to propagate the carry of the +2 add to the high order portion of the address.*



## Class 2 – Transfer and Arithmetic Instructions

**Mnemonic**  
LDX  
LDA  
STA  

**Timing**  
4\* µs for Immediate Add.  
5 µs for Direct Addressing  
6 µs for Indexed Addressing  

**Description**  
Load Index register  
Load Accumulator  
Store Accumulator  

Specified index register is loaded with a literal carried in the instruction.  
The accumulator is loaded using immediate, direct or indexed addressing modes.  
The accumulator is stored in a direct or indexed address.  
In indexed addressing modes the specified index register may be automatically incremented or decremented.  

**Binary Format**  

```
         7 6 5 4 3 2 1 0 7 6 5 4 3 2 1 0  
     LDX 1 0 0 0 0 X X X L L L L L L L L  
(LA) LDA 1 0 0 0 0 0 0 0 L L L L L L L L  
(DA) LDA 1 0 0 0 1 0 0 0 A A A A A A A A  
(IA) LDA 1 0 0 0 1 X X X A A A A A A Y Y  
(DA) STA 1 0 0 1 1 0 0 0 A A A A A A A A  
(IA) STA 1 0 0 1 1 X X X A A A A A A Y Y  
```

**Notes**  
1. X = index register number  
   L = literal  
   A = address  
   Y = index modifier  

2. LA = Immediate Addressing  
   DA = Direct Addressing  
   IA = Indexed Addressing  

3. Direct address 00000000 is invalid.



**Mnemonic**  
LIA  

**Timing**  
4\* µs  

**Description**  
Load instruction address.  
This instruction will transfer the 8 least significant bits of the current instruction address to the specified index register.  
If the instruction literal is 000, then the section and page of the current instruction address is transferred to the accumulator.  
If the literal is not 000, then the literal is transferred to the accumulator.  

**Binary Format**  

```
    7 6 5 4 3 2 1 0 7 6 5 4 3 2 1 0  
LIA 1 0 0 1 0 X X X L L L L L L L L  
```

**Notes**  
1. X = Index Register number  
2. L = Literal  
3. A = Address




**Mnemonic**  
ADX  
ADA  
SUX  
SUA  

**Timing**  
4\* µs for Immediate Addressing  
5 µs for Direct Addressing  
6 µs for Indexed Addressing  

**Description**  
Add to Index register  
Add to Accumulator  
Subtract from Accumulator  

Specified index register is operated on with the literal carried in the instruction.  
The accumulator operations specify the operand by immediate, direct or indexed addressing.  
In indexed addressing the specified index register may be automatically incremented or decremented.  

**Binary Format**  

```
         7 6 5 4 3 2 1 0 7 6 5 4 3 2 1 0  
     ADX 1 0 1 0 0 X X X L L L L L L L L  
(LA) ADA 1 0 1 0 0 0 0 0 L L L L L L L L  
(DA) ADA 1 0 1 0 1 0 0 0 A A A A A A A A  
(IA) ADA 1 0 1 0 1 X X X A A A A A A Y Y  
     SUX 1 0 1 1 0 X X X L L L L L L L L  
(LA) SUA 1 0 1 1 0 0 0 0 L L L L L L L L  
(DA) SUA 1 0 1 1 1 0 0 0 A A A A A A A A  
(IA) SUA 1 0 1 1 1 X X X A A A A A A Y Y  
```

**Notes**  
1. L = literal  
   A = address  
   X = index register  
   Y = index modifier



## Class 3 – Boolean and Compare Instructions

**Mnemonic**  
ANA  
SAN  
ERA  
SER  
IRA  
SIR  

**Timing**  
4\* µs  

**Description**  
AND to Accumulator  
Shift and AND to Accumulator  
EXCLUSIVE OR to Accumulator  
Shift and EXCLUSIVE OR to Accumulator  
INCLUSIVE OR to Accumulator  
Shift and INCLUSIVE OR to Accumulator  

**Result Table**  

| OPERAND | Accumulator | AND | EOR | IOR |
|---------|-------------|-----|-----|-----|
| 0       | 0           | 0   | 0   | 0   |
| 0       | 1           | 0   | 1   | 1   |
| 1       | 0           | 0   | 1   | 1   |
| 1       | 1           | 1   | 0   | 1   |

All shift instructions are right circular and literal addressing only.  
Remaining instructions use literal, direct or effective addressing.  
In indexed addressing mode, the specified index register may be incremented or decremented.  
Shifts take place prior to logical operation.  

**Binary Format**  

```
         7 6 5 4 3 2 1 0 7 6 5 4 3 2 1 0  
(LA) ANA 1 1 0 0 0 0 0 0 L L L L L L L L  
(DA) ANA 1 1 0 0 1 0 0 0 A A A A A A A A  
(IA) ANA 1 1 0 0 1 X X X A A A A A A Y Y  
     SAN 1 1 0 0 0 S S S L L L L L L L L  
(LA) ERA 1 1 0 1 0 0 0 0 L L L L L L L L  
(DA) ERA 1 1 0 1 1 0 0 0 A A A A A A A A  
(IA) ERA 1 1 0 1 1 X X X A A A A A A Y Y  
     SER 1 1 0 1 0 S S S L L L L L L L L  
(LA) IRA 1 1 1 0 0 0 0 0 L L L L L L L L  
(DA) IRA 1 1 1 0 1 0 0 0 A A A A A A A A  
(IA) IRA 1 1 1 0 1 X X X A A A A A A Y Y  
     SIR 1 1 1 1 0 S S S L L L L L L L L  
```

**Notes**  
1. L = literal  
   A = address  
   X = index register  
   Y = index modifier  
   S = shift count  

2. Direct address of 00000000 is invalid.


**Mnemonic**  
CPA  
CPX  

**Timing**  
4\* µs Direct Address  
6 µs Indexed Address  

**Description**  
Compare Accumulator  
Compare Index Register  

The CPX instruction compares the contents of the specified index register to the literal carried in the instruction.  
The CPA instructions compare the contents of the Accumulator to a literal or to the contents of a direct or indexed address.  
In the indexed addressing mode the index register may be incremented or decremented.  
All comparison results are stored in the Condition Register as high, low or equal.  

**Binary Format**  

```
         7 6 5 4 3 2 1 0 7 6 5 4 3 2 1 0  
     CPX 1 1 1 0 0 X X X L L L L L L L L  
(LA) CPA 1 1 1 0 0 0 0 0 L L L L L L L L  
(DA) CPA 1 1 1 0 1 0 0 0 A A A A A A A A  
(IA) CPA 1 1 1 0 1 X X X A A A A A A Y Y  
```

**Notes**  
1. L = literal  
   X = index register  
   A = address  
   Y = index modifier


## Class 1 – Branch and I/O Instructions

**Mnemonic**  
IOC  

**Timing**  
3\* µs  

**Description**  
Input/Output Control  
This instruction is used for all input and output operations.  
The IWL is used to designate the I/O sub-class and to pick the I/O device.  
The IWR designates the function to be performed.  

**Binary Format**  

```
    7 6 5 4 3 2 1 0 7 6 5 4 3 2 1 0  
IOC 0 1 1 1 1 n n n y y x x x x x x  
```

**Definition of nnn:**  

| nnn | I/O sub-class              |
|-----|----------------------------|
| 0   | current tape channel        |
| 1   | tape channel 1              |
| 2   | tape channel 2              |
| 3   | keyboard                    |
| 4   | CRT                         |
| 5   | coaxial interface           |
| 6   | communications interface    |

**Definition of yxx for the tape channel:**  

| yxx  | Function                                             |
|------|------------------------------------------------------|
| 000  | start tape fwd, slow, erase                          |
| 001  | start tape fwd, slow                                 |
| 002  | start tape fwd, fast                                 |
| 003  | start tape rev, slow                                 |
| 004  | start tape rev, fast                                 |
| 005  | stop tape                                            |
| 007  | transfer byte                                        |
| 207  | transfer byte, skip next instruction if busy         |
| 010  | write byte                                           |
| 011  | read byte                                            |
| 012  | rewind                                               |
| 016  | read status                                          |


The Read Status instruction will transfer a status word to the accumulator. This is structured as follows:  

| Acc bit | Meaning              |  
|---------|----------------------|  
| 0       | keyboard error       |  
| 1       | tape error           |  
| 2       | I/O status           |  
| 3       | runaway              |  
| 4       | cartridge out        |  
| 5       | clip out             |  
| 6       | end of tape          |  
| 7       | spare                |  

---

**Definition of yxx for the keyboard channel:**

| yxx | Function                                      |  
|-----|-----------------------------------------------|  
| 007 | transfer byte                                 |  
| 207 | transfer byte, skip next instruction if busy  |  
| 013 | keyboard beep                                 |  

**Definition of yxx for the CRT channel**

yxx for the CRT has the following structure:  

```
S S P I U D P M
```

WHERE:  
- **S** is the section bits of the page to be displayed  
- **P** is the page bits of the page to be displayed  
- **I** is the interleave bit in 8 line display mode and the half page (zone) bit in 4 line display mode  
- **U** is the underscore bit. When U = 1, any display character with a bit 6 will be underscored  
- **D** is the disable CRT bit  
- **M** is the 4/8 line mode select bit. If M = 0, the 8 line mode is selected  

If the character to be displayed has a 2^7 bit, this character position will be blanked.  

**Definition of yxx for the coaxial interface**

| yxx | Function                                      |  
|-----|-----------------------------------------------|  
| 000 | start transmit                                |  
| 001 | receive byte                                  |  
| 201 | receive byte, skip next instruction if busy   |  
| 002 | transmit data byte                            |  
| 003 | transmit control byte                         |  
| 004 | stop transmit                                 |  
| 006 | inhibit line                                  |  
| 007 | set device address                            |  
| 010 | set master mode                               |  
| 011 | set slave mode                                |  

**Definition of yxx for the communications interface**

| yxx | Function                                      |  
|-----|-----------------------------------------------|  
| 000 | transfer acc. to queue reg.                   |  
| 001 | select comm. interface mode                   |  
| 002 | transfer queue to reg. to acc.                |  
| 004 | present status                                |  
